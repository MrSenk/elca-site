{
    "en": {
        "articles": [
            {
                "id": "testing-and-quality",
                "title": "Testing Isn't Just for Checkboxes",
                "date": "2024-03-15",
                "summary": "Stop treating tests like a chore. I'll show you why a good test suite is the only thing standing between you and a 3 AM production outage.",
                "content": [
                    {
                        "type": "text",
                        "value": "Look, I get it. You just spent 8 hours building a complex trigger, and now you have to write test coverage. It's tempting to just write a `testMethod` that calls your code and asserts nothing just to hit that 75% bar."
                    },
                    {
                        "type": "text",
                        "value": "Don't be that guy. That 75% isn't a goal; it's a bare minimum. Coverage doesn't mean *quality*."
                    },
                    {
                        "type": "heading",
                        "value": "The 3 AM Wake-Up Call"
                    },
                    {
                        "type": "text",
                        "value": "I once deployed a 'perfect' feature. Two weeks later, a validation rule change broke it. Because I didn't assert my expected outcomes, the system failed silently until a VP tried to close a deal. Trust me, you don't want that phone call."
                    },
                    {
                        "type": "heading",
                        "value": "Arrange, Act, Assert"
                    },
                    {
                        "type": "text",
                        "value": "This is the holy trinity. Set up your data (Arrange), run your code (Act), and then, most importantly, prove it did what it was supposed to (Assert)."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nprivate class AccountTriggerTest {\n    @isTest\n    static void shouldUpdateOpportunitiesOnAccountClosure() {\n        // Arrange: valid data\n        Account testAcc = new Account(Name = 'Test Account');\n        insert testAcc;\n        \n        // Act: do the thing\n        Test.startTest();\n        testAcc.Status__c = 'Closed';\n        update testAcc;\n        Test.stopTest();\n        \n        // Assert: PROVE it worked\n        Opportunity updatedOpp = [SELECT StageName FROM Opportunity WHERE Id = :testOpp.Id];\n        Assert.areEqual('Closed Lost', updatedOpp.StageName, 'Opportunity NOT closed? Fix it.');\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "If you aren't using `Assert.areEqual`, you aren't testing. You're just wasting space."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Assert Class",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Assert.htm"
                            },
                            {
                                "title": "Testing Best Practices",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_best_practices.htm"
                            },
                            {
                                "title": "Testing Apex",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing.htm"
                            },
                            {
                                "title": "Testing Example",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_example.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "automation",
                "title": "Flow is Powerful (But Use It Wisely)",
                "date": "2026-01-05",
                "summary": "Flow is powerful, but it's not a silver bullet. Learn when to use it, when to code, and how to avoid introducing unnecessary complexity.",
                "content": [
                    {
                        "type": "text",
                        "value": "I like Flow. It's democratic, it's visual, and it lets Admins do things that used to require a week of my time. But with great power comes great ability to completely wreck an org."
                    },
                    {
                        "type": "heading",
                        "value": "The 'No-Code' Trap"
                    },
                    {
                        "type": "text",
                        "value": "Just because you *can* build it in Flow doesn't mean you *should*. If I see a Flow with 50 elements just to loop through a collection and update records, I'm declining that Pull Request. Why? Because 5 lines of Apex is faster, cleaner, and easier to debug."
                    },
                    {
                        "type": "heading",
                        "value": "Don't Feed the Spaghetti Monster"
                    },
                    {
                        "type": "text",
                        "value": "Click-and-drag is fun until you have a canvas that looks like a bowl of noodles dropped on the floor. If you can't explain your Flow logic in 3 sentences, it's too complex. Break it up. Use Subflows. Better yet, use Invocable Apex."
                    },
                    {
                        "type": "heading",
                        "value": "The Golden Rule"
                    },
                    {
                        "type": "text",
                        "value": "One Record-Triggered Flow per Object. I don't care what the new features say. If you have 5 different flows firing on Opportunity update, you don't have an architecture; you have a race condition waiting to happen."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Flow Builder Best Practices",
                                "url": "https://help.salesforce.com/s/articleView?id=sf.flow_prep_bestpractices.htm"
                            },
                            {
                                "title": "Automation with Flow",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.salesforce_vpm_guide.meta/salesforce_vpm_guide/vpm_intro.htm"
                            },
                            {
                                "title": "When to Use Flow vs Apex",
                                "url": "https://architect.salesforce.com/decision-guides/trigger-automation"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "debugging",
                "title": "Debugging: CSI Salesforce",
                "date": "2026-01-05",
                "summary": "Production is down. Everyone is screaming. Don't panic. Put on your detective hat and let's look at the logs.",
                "content": [
                    {
                        "type": "text",
                        "value": "Your phone buzzes. Users are getting a 'Script-Thrown Exception'. Your adrenaline spikes. Stop. Take a breath."
                    },
                    {
                        "type": "heading",
                        "value": "The Crime Scene (Logs)"
                    },
                    {
                        "type": "text",
                        "value": "Salesforce logs are notoriously ugly. They are huge, verbose, and intimidating. But the truth is in there. Search for `USER_DEBUG` or `EXCEPTION_THROWN`. Ignore the noise."
                    },
                    {
                        "type": "heading",
                        "value": "Reproduce the Crime"
                    },
                    {
                        "type": "text",
                        "value": "If you can't reproduce it, you can't fix it. Do not just blindly deploy a 'fix' hoping it works. You need to verify the bug in a Sandbox first. Same data, same user, same steps."
                    },
                    {
                        "type": "heading",
                        "value": "Checkpoints"
                    },
                    {
                        "type": "text",
                        "value": "Can't add `System.debug` statements in Production? Use Checkpoints in the Developer Console. They let you inspect memory at a specific line of code without deploying changes. It's magic."
                    },
                    {
                        "type": "text",
                        "value": "And when all else fails? Rubber Duck Debugging. Explain your code line-by-line to an inanimate object. You'll be surprised how often you find the bug yourself."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Debug Log Basics",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_debugging_debug_log.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "careers",
                "title": "The Senior Mindset: It's Not Just Code",
                "date": "2026-01-05",
                "summary": "Let's talk about the 'Soft Skills' that are actually hard.",
                "content": [
                    {
                        "type": "text",
                        "value": "I used to think being a Senior Developer meant knowing every obscure specific of the internal Apex compiler. I was wrong."
                    },
                    {
                        "type": "heading",
                        "value": "The Shift"
                    },
                    {
                        "type": "text",
                        "value": "A Junior Developer asks: 'How do I build this?' A Senior Developer asks: 'Should we build this?' Your job isn't just to write code; it's to solve problems. Sometimes the best line of code is the one you didn't write because you convinced the stakeholder to use standard functionality."
                    },
                    {
                        "type": "heading",
                        "value": "The Power of 'No'"
                    },
                    {
                        "type": "text",
                        "value": "Protecting your org is your primary duty. When a request comes in that you know will create technical debt, you have to say no. But don't just say 'No'. Say 'No, but here is a better way'."
                    },
                    {
                        "type": "heading",
                        "value": "Ownership"
                    },
                    {
                        "type": "text",
                        "value": "When Production breaks at 5 PM on a Friday, a Junior looks for a Manager. A Senior looks for the logs. Ownership means you treat the code as your own, even the legacy spaghetti you didn't write."
                    },
                    {
                        "type": "heading",
                        "value": "Mentorship"
                    },
                    {
                        "type": "text",
                        "value": "You haven't mastered a concept until you can explain it to a Junior without making them feel stupid. Lift others up. That's the true mark of seniority."
                    }
                ]
            },
            {
                "id": "pagination-cursors",
                "title": "Pagination Cursors: The End of OFFSET Nightmares",
                "date": "2026-01-06",
                "summary": "There's a new beta feature that's going to change how you handle large datasets.",
                "content": [
                    {
                        "type": "text",
                        "value": "I need to tell you about a beta feature that's quietly rolling out. If you've ever hit the OFFSET limit, written fragile ID-based pagination, or fired up Batch Apex just to process 10,000 records, this is for you."
                    },
                    {
                        "type": "heading",
                        "value": "The Old Way Was Painful"
                    },
                    {
                        "type": "text",
                        "value": "Let's be honest. OFFSET maxes out at 2,000 rows and gets slower the deeper you go. ID-based pagination (`WHERE Id > :lastId`) works, but it's fragile and breaks if records get deleted. And Batch Apex? It's powerful, but it's like using a bulldozer to move a couch."
                    },
                    {
                        "type": "heading",
                        "value": "Enter: PaginationCursor"
                    },
                    {
                        "type": "text",
                        "value": "Salesforce now lets you pause and resume a SOQL query without re-executing it. The platform tracks your position for you. Here's what it looks like:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "Integer pageSize = 200;\n\nDatabase.QueryLocator locator = Database.getQueryLocator(\n    'SELECT Id, Name FROM Account ORDER BY CreatedDate'\n);\n\nPaginationCursor cursor = locator.getPaginationCursor();\nList<Account> page = locator.fetch(pageSize);\n\nwhile (!page.isEmpty()) {\n    // Process your records\n    for (Account acc : page) {\n        System.debug(acc.Name);\n    }\n    \n    // Get the next page\n    page = locator.fetch(pageSize);\n}"
                    },
                    {
                        "type": "text",
                        "value": "No OFFSET. No manual ID tracking. Just fetch the next chunk."
                    },
                    {
                        "type": "heading",
                        "value": "The Killer Feature: Serialization"
                    },
                    {
                        "type": "text",
                        "value": "Here's where it gets good. You can serialize the cursor, store it, and resume later. Perfect for long-running integrations or async jobs that might get interrupted."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Store it\nString cursorState = JSON.serialize(cursor);\n// Save to Custom Object, Platform Cache, etc.\n\n// Resume later\nPaginationCursor cursor = (PaginationCursor) JSON.deserialize(\n    cursorState,\n    PaginationCursor.class\n);"
                    },
                    {
                        "type": "heading",
                        "value": "When to Use It"
                    },
                    {
                        "type": "text",
                        "value": "Use cursors for: backend processing, async jobs, large data migrations. Don't use them for: real-time UI pagination in LWC or Visualforce. And always include a deterministic ORDER BY clause, cursors need consistent ordering."
                    },
                    {
                        "type": "text",
                        "value": "This is still beta, so test thoroughly. But if you're tired of OFFSET hacks and Batch Apex complexity, give PaginationCursor a try. It's one of those features that just makes sense."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Use Apex Cursors for Expanded SOQL Query Result Support (Generally Available)",
                                "url": "https://help.salesforce.com/s/articleView?id=release-notes.rn_apex_cursors.htm&release=260&type=5"
                            },
                            {
                                "title": "SOQL Query Limits",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.soql_sosl.meta/soql_sosl/sforce_api_calls_soql_select_offset.htm"
                            },
                            {
                                "title": "Batch Apex vs Pagination Cursors",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_batch.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "lwc-communication",
                "title": "Talking to Your Components: Props Down, Events Up",
                "date": "2026-01-06",
                "summary": "Parent and child components need to communicate. Learn the golden rule of LWC: data flows down via props, events bubble up.",
                "content": [
                    {
                        "type": "text",
                        "value": "If you've built more than a 'Hello World' LWC, you've hit this: how do I pass data between components? The answer is beautifully simple. Props go down, events go up. That's it. Master this pattern and you'll build cleaner, more composable components."
                    },
                    {
                        "type": "heading",
                        "value": "Props: Parent Controls the Child"
                    },
                    {
                        "type": "text",
                        "value": "Think of props as parameters to a function. The parent supplies them, the child receives them. In LWC, you make a property public using the @api decorator. That's your signal: 'Hey, parent components can set this'."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// childComponent.js\nimport { LightningElement, api } from 'lwc';\n\nexport default class ChildComponent extends LightningElement {\n    @api recordName;  // Public property\n    @api isActive = false;  // Public with default value\n}"
                    },
                    {
                        "type": "text",
                        "value": "Now the parent can pass data in via attributes, just like you'd pass arguments to a function:"
                    },
                    {
                        "type": "code",
                        "language": "html",
                        "value": "<!-- parentComponent.html -->\n<template>\n    <c-child-component \n        record-name={contactName}\n        is-active={status}>\n    </c-child-component>\n</template>"
                    },
                    {
                        "type": "text",
                        "value": "Notice the kebab-case in HTML (record-name) vs camelCase in JavaScript (recordName)? That's web standards. LWC follows them religiously."
                    },
                    {
                        "type": "heading",
                        "value": "The One-Way Street"
                    },
                    {
                        "type": "text",
                        "value": "Props flow DOWN only. The child cannot, and should not, mutate a prop value. If you try to reassign this.recordName in the child, you're breaking the contract. Parent owns the data. Child displays it."
                    },
                    {
                        "type": "heading",
                        "value": "Events: Child Informs the Parent"
                    },
                    {
                        "type": "text",
                        "value": "So if the child can't change props, how does it communicate back? Events. When something happens in the child that the parent needs to know about, fire an event. The parent listens and decides what to do."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// childComponent.js\nimport { LightningElement } from 'lwc';\n\nexport default class ChildComponent extends LightningElement {\n    handleClick() {\n        // Create the event\n        const event = new CustomEvent('select', {\n            detail: { recordId: this.recordId }\n        });\n        \n        // Dispatch it\n        this.dispatchEvent(event);\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Event names should be lowercase, no spaces, use underscores if you need multiple words. And never prefix with 'on', that creates confusion in the markup."
                    },
                    {
                        "type": "heading",
                        "value": "Parent Listens"
                    },
                    {
                        "type": "text",
                        "value": "The parent component listens using the onEventName syntax. Since our event is called 'select', we use onselect:"
                    },
                    {
                        "type": "code",
                        "language": "html",
                        "value": "<!-- parentComponent.html -->\n<template>\n    <c-child-component \n        onselect={handleSelection}>\n    </c-child-component>\n</template>"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// parentComponent.js\nimport { LightningElement } from 'lwc';\n\nexport default class ParentComponent extends LightningElement {\n    handleSelection(event) {\n        const recordId = event.detail.recordId;\n        // Do something with the data\n        console.log('Selected record:', recordId);\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "The data you passed in the 'detail' property? That's how you access it: event.detail. Simple."
                    },
                    {
                        "type": "heading",
                        "value": "The Detail Property: Send Primitives"
                    },
                    {
                        "type": "text",
                        "value": "Here's a trap. JavaScript passes objects by reference. If you send an object in event.detail and the parent mutates it, you just changed the child's data without its knowledge. Bad.\n\nStick to primitives (strings, numbers, booleans) in your detail payload. If you must send an object, clone it first using spread syntax or Object.assign()."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// GOOD: Sending primitives\nconst event = new CustomEvent('update', {\n    detail: { id: this.recordId, name: this.name }\n});\n\n// ACCEPTABLE: Cloning an object\nconst event = new CustomEvent('update', {\n    detail: { ...this.recordData }\n});"
                    },
                    {
                        "type": "heading",
                        "value": "Real-World Example"
                    },
                    {
                        "type": "text",
                        "value": "Let's say you're building a contact list. The parent (c-contact-list) manages the list. Each child (c-contact-tile) displays one contact. When a user clicks a tile, the parent needs to know which contact was selected."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// contactTile.js (CHILD)\nimport { LightningElement, api } from 'lwc';\n\nexport default class ContactTile extends LightningElement {\n    @api contact;  // Parent passes the contact\n\n    handleClick() {\n        const selectEvent = new CustomEvent('contactselect', {\n            detail: { contactId: this.contact.Id }\n        });\n        this.dispatchEvent(selectEvent);\n    }\n}"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// contactList.js (PARENT)\nimport { LightningElement, wire } from 'lwc';\nimport getContacts from '@salesforce/apex/ContactController.getContacts';\n\nexport default class ContactList extends LightningElement {\n    selectedContactId;\n    @wire(getContacts) contacts;\n\n    handleContactSelect(event) {\n        this.selectedContactId = event.detail.contactId;\n        // Now fetch details, update UI, etc.\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "The child doesn't know or care what the parent does with the event. Maybe it displays details. Maybe it triggers a navigation. Doesn't matter. The child's job is done: it announced something happened."
                    },
                    {
                        "type": "heading",
                        "value": "Why This Matters"
                    },
                    {
                        "type": "text",
                        "value": "This pattern keeps your components decoupled. The child component is reusable. Drop it anywhere, listen to its events, and you're done. No tight coupling. No parent references. Just clean, composable code.\n\nProps down. Events up. It's the LWC way. Learn it, and your components will thank you."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Communicate with Events",
                                "url": "https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.events"
                            },
                            {
                                "title": "Public Properties",
                                "url": "https://developer.salesforce.com/docs/platform/lwc/guide/reactivity-public.html"
                            },
                            {
                                "title": "Create and Dispatch Events",
                                "url": "https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.events_create_dispatch"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "lwc-decorators",
                "title": "Decorators: The Magic @ Symbols That Actually Matter",
                "date": "2026-01-06",
                "summary": "Stop cargo-culting @track on every field. Learn what @api, @wire, and @track actually do, and when you actually need them.",
                "content": [
                    {
                        "type": "text",
                        "value": "I see this all the time in code reviews: every single field decorated with @track. When I ask why, the answer is always 'to make it reactive.' Wrong. Since Spring '20, all fields are reactive by default. You're just adding noise."
                    },
                    {
                        "type": "heading",
                        "value": "The Three Musketeers"
                    },
                    {
                        "type": "text",
                        "value": "LWC gives you three decorators. Each has a specific purpose. Use the wrong one, or overuse them, and you're making your code harder to read for zero benefit."
                    },
                    {
                        "type": "heading",
                        "value": "@api: The Public Contract"
                    },
                    {
                        "type": "text",
                        "value": "Use @api when you want a property or method to be accessible from outside the component. This is your component's public API. Parent components can set these properties. Other code can call these methods."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "import { LightningElement, api } from 'lwc';\n\nexport default class MyComponent extends LightningElement {\n    @api recordId;  // Parent can set this\n    @api itemName;  // Public property\n    \n    @api refresh() {  // Public method\n        // Parent can call this\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "If you're not exposing it to a parent or using it in App Builder, don't use @api. Simple as that."
                    },
                    {
                        "type": "heading",
                        "value": "@wire: Reactive Data from Salesforce"
                    },
                    {
                        "type": "text",
                        "value": "@wire connects your component to Salesforce data. Use it with Lightning Data Service (LDS) or Apex methods. The framework automatically refreshes your component when the underlying data changes."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "import { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n\nexport default class RecordViewer extends LightningElement {\n    @api recordId;\n    \n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    record;\n}"
                    },
                    {
                        "type": "text",
                        "value": "When recordId changes, the wire adapter automatically refetches the data. No manual calls. No lifecycle hooks. It just works."
                    },
                    {
                        "type": "heading",
                        "value": "@track: The Misunderstood One"
                    },
                    {
                        "type": "text",
                        "value": "Here's where everyone gets it wrong. Before Spring '20, you needed @track to make fields reactive. Not anymore. All fields are reactive now."
                    },
                    {
                        "type": "text",
                        "value": "Do NOT use @track on primitives. It does nothing. This is pointless:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// WRONG: Unnecessary\n@track firstName = '';  // String is already reactive\n@track count = 0;       // Number is already reactive\n@track isActive = false; // Boolean is already reactive"
                    },
                    {
                        "type": "text",
                        "value": "So when DO you use @track? Only when you need to observe changes to the INTERNALS of an object or array."
                    },
                    {
                        "type": "heading",
                        "value": "When @track Matters: Objects"
                    },
                    {
                        "type": "text",
                        "value": "Let's say you have an object and you're changing a property inside it, not reassigning the whole object. Without @track, the framework won't detect the change."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// WITHOUT @track\nuser = { firstName: 'John', lastName: 'Doe' };\n\nhandleClick() {\n    // This WON'T trigger a rerender\n    this.user.firstName = 'Jane';\n}"
                    },
                    {
                        "type": "text",
                        "value": "Why? Because the user object reference didn't change. It's still the same object. The framework compares using ===, and user === user is true."
                    },
                    {
                        "type": "text",
                        "value": "Two solutions. Either reassign the entire object:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// Solution 1: Reassign the whole object\nhandleClick() {\n    this.user = { ...this.user, firstName: 'Jane' };\n    // Now user is a NEW object, framework detects change\n}"
                    },
                    {
                        "type": "text",
                        "value": "Or use @track to tell the framework to watch the internals:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// Solution 2: Use @track\n@track user = { firstName: 'John', lastName: 'Doe' };\n\nhandleClick() {\n    this.user.firstName = 'Jane';  // NOW it rerenders\n}"
                    },
                    {
                        "type": "heading",
                        "value": "When @track Matters: Arrays"
                    },
                    {
                        "type": "text",
                        "value": "Same issue with arrays. If you push, pop, or modify elements without reassigning the array, the framework won't detect it. Unless you use @track."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// WITHOUT @track\nitems = ['Apple', 'Banana'];\n\naddItem() {\n    this.items.push('Cherry');  // WON'T rerender\n}"
                    },
                    {
                        "type": "text",
                        "value": "Solutions: reassign or @track."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// Solution 1: Reassign\naddItem() {\n    this.items = [...this.items, 'Cherry'];\n}\n\n// Solution 2: Use @track\n@track items = ['Apple', 'Banana'];\n\naddItem() {\n    this.items.push('Cherry');  // NOW it works\n}"
                    },
                    {
                        "type": "heading",
                        "value": "@track Doesn't Work on Everything"
                    },
                    {
                        "type": "text",
                        "value": "Important caveat: @track only works on plain objects ({}) and arrays ([]). It does NOT work on class instances, Date, Set, or Map."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// This WON'T work even with @track\n@track myDate = new Date();\n\nchangeDate() {\n    this.myDate.setFullYear(2025);  // NOT observed\n}"
                    },
                    {
                        "type": "text",
                        "value": "For complex objects like Date, always reassign:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "changeDate() {\n    const newDate = new Date(this.myDate);\n    newDate.setFullYear(2025);\n    this.myDate = newDate;  // Reassignment triggers rerender\n}"
                    },
                    {
                        "type": "heading",
                        "value": "The Decision Tree"
                    },
                    {
                        "type": "text",
                        "value": "Here's how to decide:\n\n1. Does a parent need to set it? → @api\n2. Does it come from Salesforce via LDS or Apex? → @wire\n3. Is it a primitive (string, number, boolean)? → No decorator needed\n4. Is it an object/array and you mutate internals? → @track OR reassign\n5. Everything else? → No decorator"
                    },
                    {
                        "type": "heading",
                        "value": "Real-World Example"
                    },
                    {
                        "type": "text",
                        "value": "Let's say you're building a shopping cart component."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "import { LightningElement, api, track } from 'lwc';\n\nexport default class ShoppingCart extends LightningElement {\n    @api cartId;  // Parent sets this\n    \n    @track items = [];  // We'll push/pop items\n    \n    totalPrice = 0;  // Primitive, no decorator needed\n    \n    addItem(item) {\n        this.items.push(item);  // @track makes this reactive\n        this.totalPrice += item.price;  // Primitive reassignment\n    }\n    \n    removeItem(index) {\n        this.items.splice(index, 1);  // @track observes this\n        this.recalculateTotal();\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Notice: @api for public properties, @track for the array we mutate, and no decorator for the primitive totalPrice."
                    },
                    {
                        "type": "heading",
                        "value": "Stop Decorating Everything"
                    },
                    {
                        "type": "text",
                        "value": "The biggest mistake? Slapping @track on every field 'just in case.' It's code clutter. It signals to other devs that you don't understand reactivity.\n\nUse decorators intentionally. Each @ symbol should have a reason. If you can't explain why you used it, you probably shouldn't have."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "LWC Decorators Reference",
                                "url": "https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_decorators"
                            },
                            {
                                "title": "Understand the Wire Service",
                                "url": "https://developer.salesforce.com/docs/platform/lwc/guide/data-wire-service-about.html"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "clean-coder-lessons",
                "title": "I Just Finished 'The Clean Coder.' Here's What Hit Different.",
                "date": "2026-01-06",
                "summary": "These are the lessons I'm actually trying to apply, not because they're new, but because I finally get why they matter.",
                "content": [
                    {
                        "type": "text",
                        "value": "I'll be honest: I picked up 'The Clean Coder' expecting to skim it. I've been doing this for years. How much could Robert Martin really teach me about professionalism? Turns out, a lot. Not because I didn't know these things intellectually, but because I hadn't been living them."
                    },
                    {
                        "type": "heading",
                        "value": "Saying No is a Skill, Not Insubordination"
                    },
                    {
                        "type": "text",
                        "value": "This one stung. How many times have I said 'yes' to an unrealistic deadline just to avoid conflict? Martin's point is clear: saying 'yes' when you should say 'no' isn't being a team player, it's lying."
                    },
                    {
                        "type": "text",
                        "value": "If a manager asks for a feature by Friday and you know it'll take two weeks, saying 'I'll try' is setting everyone up for failure. The professional answer is 'No, but I can have it done in two weeks.' And then you negotiate."
                    },
                    {
                        "type": "text",
                        "value": "I'm working on this. It's uncomfortable. But a missed promise hurts the team more than an honest 'no' ever could."
                    },
                    {
                        "type": "heading",
                        "value": "You Own Your Career, Not Your Employer"
                    },
                    {
                        "type": "text",
                        "value": "Martin hammers this: your employer owes you a paycheck, not a career. If you're not spending time outside work keeping your skills sharp, you're falling behind. And that's on you."
                    },
                    {
                        "type": "text",
                        "value": "Twenty hours a week sounds extreme, but the point isn't the number. It's the mindset. Read. Practice. Build things that don't ship to production. Learn that new framework before the project demands it."
                    },
                    {
                        "type": "text",
                        "value": "I used to think 'I code all day, isn't that enough?' No. The stuff I build at work exercises old muscles. Personal projects and deliberate practice build new ones."
                    },
                    {
                        "type": "heading",
                        "value": "Testing Isn't Optional"
                    },
                    {
                        "type": "text",
                        "value": "This isn't new advice, but Martin's framing hit me: if you don't test your code, how do you know it works? 'It worked on my machine' isn't professionalism. It's hope."
                    },
                    {
                        "type": "text",
                        "value": "I've been writing tests for coverage, not confidence. That's the problem. Tests should make me certain the code works, not just check a box for deployment."
                    },
                    {
                        "type": "text",
                        "value": "Now I'm trying to write tests first, not religiously TDD, but enough to think through the API before I write the implementation. It's slower upfront. It's faster overall."
                    },
                    {
                        "type": "heading",
                        "value": "Know When You're Tired"
                    },
                    {
                        "type": "text",
                        "value": "Martin talks about the 3 AM debugging session that creates more bugs than it fixes. I've lived this. You think you're being dedicated. You're actually being reckless."
                    },
                    {
                        "type": "text",
                        "value": "Code written while exhausted is code you'll delete in the morning. Step away. Sleep. The problem will still be there, but your brain will actually work."
                    },
                    {
                        "type": "text",
                        "value": "This applies to meetings too. If you're zoned out in a planning session because you're burned out, you're not helping. You're a warm body taking up space."
                    },
                    {
                        "type": "heading",
                        "value": "Practice Like an Athlete"
                    },
                    {
                        "type": "text",
                        "value": "Athletes don't just play games. They drill. They practice. Why don't we? Martin suggests code katas, small exercises you repeat to build muscle memory."
                    },
                    {
                        "type": "text",
                        "value": "I tried this. Implementing a simple algorithm multiple times, trying different approaches. It felt silly at first. Then I realized: I was learning patterns without the pressure of a deadline."
                    },
                    {
                        "type": "text",
                        "value": "When a similar problem showed up at work, I didn't have to think. My hands knew what to do. That's the point."
                    },
                    {
                        "type": "heading",
                        "value": "Estimation is Not a Commitment"
                    },
                    {
                        "type": "text",
                        "value": "I used to treat estimates like promises. Manager asks how long something will take, I say three days, then I kill myself to hit three days even when reality says five."
                    },
                    {
                        "type": "text",
                        "value": "Martin's advice: give a range. 'Best case: three days. Worst case: a week. Most likely: five days.' And then stick to it. If you discover new complexity, update the estimate. Don't just work weekends to preserve your original guess."
                    },
                    {
                        "type": "text",
                        "value": "Estimates are probabilities, not contracts. Treating them as contracts just means you'll be wrong and exhausted."
                    },
                    {
                        "type": "heading",
                        "value": "The Code Isn't Yours"
                    },
                    {
                        "type": "text",
                        "value": "Ego in code review is poison. Someone points out a better way to do something, and the instinct is defensiveness. 'But my way works.' Sure. And their way works better."
                    },
                    {
                        "type": "text",
                        "value": "Martin's point: you're not your code. Criticism of your code is not criticism of you. It's a gift. Someone just made your work better for free."
                    },
                    {
                        "type": "text",
                        "value": "I'm trying to reframe this. When a junior dev finds a bug I missed, that's not embarrassing. That's the system working. Peer review caught it before production did."
                    },
                    {
                        "type": "heading",
                        "value": "What I'm Actually Changing"
                    },
                    {
                        "type": "text",
                        "value": "Reading the book is easy. Applying it is hard. Here's what I'm committing to:\n\n1. Say 'no' when I mean no. Negotiate, don't capitulate.\n2. Carve out time every week for deliberate practice. Not just 'learning on the job.'\n3. Write tests that give me confidence, not just coverage.\n4. Walk away when I'm too tired to think.\n5. Treat estimates as forecasts, not promises.\n6. Check my ego at the door in code reviews."
                    },
                    {
                        "type": "text",
                        "value": "None of this is revolutionary. But reading Martin say it, backed by decades of war stories, made it click."
                    },
                    {
                        "type": "text",
                        "value": "I'm not a perfect professional. But I'm working on it. And that's the point."
                    }
                ]
            },
            {
                "id": "run-relevant-tests",
                "title": "RunRelevantTests: Deploy Faster Without the Wait",
                "date": "2026-01-08",
                "summary": "Here's what RunRelevantTests does and why you should care.",
                "content": [
                    {
                        "type": "text",
                        "value": "Let's talk about deployment pain. You change one trigger. One. And then you wait 20 minutes while RunLocalTests executes every single test in your org, including that ancient AccountTest from 2018 that has nothing to do with your change."
                    },
                    {
                        "type": "text",
                        "value": "Salesforce heard us. The new RunRelevantTests test level is in beta, and it's exactly what it sounds like: run only the tests that matter for your deployment."
                    },
                    {
                        "type": "heading",
                        "value": "The Problem with RunLocalTests"
                    },
                    {
                        "type": "text",
                        "value": "RunLocalTests is the default for production deployments. It runs every test in your org except managed packages. In a mature org with hundreds of test classes, this gets slow. Really slow. And it doesn't scale, whether you're deploying one class or fifty, you're running the same massive test suite."
                    },
                    {
                        "type": "text",
                        "value": "RunSpecifiedTests lets you pick specific tests, but now you need custom DevOps tooling to figure out which tests to run. You're trading deployment time for engineering time."
                    },
                    {
                        "type": "heading",
                        "value": "Enter RunRelevantTests"
                    },
                    {
                        "type": "text",
                        "value": "RunRelevantTests analyzes your deployment payload and runs only the tests that are relevant to what you're changing. The engine looks at dependencies, figures out what's impacted, and executes just those tests. Small deployment? Small test run. It scales."
                    },
                    {
                        "type": "heading",
                        "value": "How to Use It"
                    },
                    {
                        "type": "text",
                        "value": "If you're using Salesforce CLI, it's one flag:"
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "sf project deploy start --test-level RunRelevantTests"
                    },
                    {
                        "type": "text",
                        "value": "If you're using the Metadata API directly, set the testLevel field on your DeployOptions:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "DeployOptions options = new DeployOptions();\noptions.testLevel = 'RunRelevantTests';\n// Pass to deploy() method"
                    },
                    {
                        "type": "text",
                        "value": "That's it. The engine handles the rest."
                    },
                    {
                        "type": "heading",
                        "value": "Fine-Grained Control with Annotations"
                    },
                    {
                        "type": "text",
                        "value": "Sometimes you need more control. Salesforce added two new @IsTest annotations (available in API version 66.0+) to let you specify test behavior."
                    },
                    {
                        "type": "heading",
                        "value": "@IsTest(critical=true)"
                    },
                    {
                        "type": "text",
                        "value": "Use this when a test must ALWAYS run, no matter what's in the deployment. Think integration tests, end-to-end flows, or tests that validate critical business logic across multiple components."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@IsTest(critical=true)\nprivate class CriticalBusinessFlowTest {\n    @isTest\n    static void testEndToEndOrderProcessing() {\n        // This runs on EVERY deployment\n        // Use sparingly\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Don't abuse this. If every test is critical, nothing is critical. Reserve it for tests that genuinely need to run every time."
                    },
                    {
                        "type": "heading",
                        "value": "@IsTest(testFor='...')"
                    },
                    {
                        "type": "text",
                        "value": "This annotation lets you explicitly declare dependencies. If your test should run whenever specific classes or triggers are modified, list them:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@IsTest(testFor='ApexClass:AccountService, ApexTrigger:OpportunityTrigger')\nprivate class AccountOpportunityIntegrationTest {\n    @isTest\n    static void testAccountUpdateTriggersOpportunityLogic() {\n        // Runs when AccountService OR OpportunityTrigger changes\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Notice the syntax: 'ApexClass:ClassName' or 'ApexTrigger:TriggerName'. You can list multiple components separated by commas."
                    },
                    {
                        "type": "heading",
                        "value": "When to Use RunRelevantTests"
                    },
                    {
                        "type": "text",
                        "value": "This is perfect for CI/CD pipelines where you're deploying frequently. Faster feedback loops mean faster iteration. But remember: this is still beta. Test it in your sandbox environments first. Validate that the engine is selecting the right tests for your use cases."
                    },
                    {
                        "type": "text",
                        "value": "And don't abandon RunLocalTests entirely. For major releases or pre-production validation, you still want the full suite. RunRelevantTests is for speed during development, not for replacing comprehensive testing."
                    },
                    {
                        "type": "heading",
                        "value": "The Gotchas"
                    },
                    {
                        "type": "text",
                        "value": "1. This is beta. Expect changes before GA.\n2. You still need to meet the 75% code coverage requirement.\n3. The engine is smart, but it's not psychic. If you have weird dependencies it doesn't detect, use the annotations.\n4. Available in Enterprise, Performance, Unlimited, and Developer editions only."
                    },
                    {
                        "type": "heading",
                        "value": "The Bottom Line"
                    },
                    {
                        "type": "text",
                        "value": "RunRelevantTests is one of those features that just makes sense. Deployments should be fast. Tests should be targeted. If you're tired of waiting for unrelated tests to finish, give this a try. Just remember it's beta, test thoroughly, provide feedback to Salesforce, and don't bet your production deployments on it until it hits GA."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Deploy Apex Components Faster by Running Only Relevant Tests (Beta)",
                                "url": "https://help.salesforce.com/s/articleView?id=release-notes.rn_apex_run_relevant_tests.htm&release=260&type=5"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "picklist-values-record-type",
                "title": "Finally: Get Picklist Values by Record Type in Apex",
                "date": "2026-01-08",
                "summary": "Salesforce just gave us a native way to get record-type-specific picklist values in Apex.",
                "content": [
                    {
                        "type": "text",
                        "value": "If you've ever tried to get picklist values for a specific record type in Apex, you know the pain. You either make a callout to the UI API, use some hacky Schema.DescribeFieldResult workaround, or just give up and hardcode the values. None of these are good."
                    },
                    {
                        "type": "text",
                        "value": "Salesforce heard us on IdeaExchange. The new ConnectApi.RecordUi.getPicklistValuesByRecordType() method is here, and it does exactly what it says on the tin."
                    },
                    {
                        "type": "heading",
                        "value": "The Old Way Was Painful"
                    },
                    {
                        "type": "text",
                        "value": "Before this, if you wanted picklist values filtered by record type, you had two bad options:"
                    },
                    {
                        "type": "text",
                        "value": "1. Make a callout to the UI API from Apex (async, complex, governor limits)\n2. Use Schema describes and manually filter by record type (verbose, error-prone)"
                    },
                    {
                        "type": "text",
                        "value": "And if you had dependent picklists? Good luck. You'd need multiple calls or complex logic to traverse the dependency tree."
                    },
                    {
                        "type": "heading",
                        "value": "The New Way is Clean"
                    },
                    {
                        "type": "text",
                        "value": "One method. One call. All your picklist values for a specific record type."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Get all picklist values for a record type\nConnectApi.PicklistValuesCollection picklistValues = \n    ConnectApi.RecordUi.getPicklistValuesByRecordType(\n        'Account',           // Object API name\n        '012xx000000abcdAAA'  // Record Type ID\n    );"
                    },
                    {
                        "type": "text",
                        "value": "That's it. The method returns a PicklistValuesCollection containing all picklist fields and their values for that record type."
                    },
                    {
                        "type": "heading",
                        "value": "Accessing the Values"
                    },
                    {
                        "type": "text",
                        "value": "The returned collection is a map of field API names to their picklist values. Here's how you access them:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Get values for a specific field\nConnectApi.PicklistValues industryValues = \n    picklistValues.picklistFieldValues.get('Industry');\n\n// Loop through the values\nfor (ConnectApi.PicklistValue value : industryValues.values) {\n    System.debug('Label: ' + value.label);\n    System.debug('API Value: ' + value.value);\n    System.debug('Is Default: ' + value.defaultValue);\n}"
                    },
                    {
                        "type": "heading",
                        "value": "The Killer Feature: Dependent Picklists"
                    },
                    {
                        "type": "text",
                        "value": "This is where it gets good. If you have a tree of dependent picklists, say Continent__c controls Country__c, which controls City__c, this method gets ALL the values in ONE call."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "ConnectApi.PicklistValuesCollection allPicklists = \n    ConnectApi.RecordUi.getPicklistValuesByRecordType(\n        'Location__c',\n        recordTypeId\n    );\n\n// Get continent values\nConnectApi.PicklistValues continents = \n    allPicklists.picklistFieldValues.get('Continent__c');\n\n// Get country values (includes ALL countries for ALL continents)\nConnectApi.PicklistValues countries = \n    allPicklists.picklistFieldValues.get('Country__c');\n\n// Get city values (includes ALL cities for ALL countries)\nConnectApi.PicklistValues cities = \n    allPicklists.picklistFieldValues.get('City__c');"
                    },
                    {
                        "type": "text",
                        "value": "Each PicklistValue object includes a validFor property that tells you which controlling values it's valid for. This is how you build the dependency logic."
                    },
                    {
                        "type": "heading",
                        "value": "Real-World Example"
                    },
                    {
                        "type": "text",
                        "value": "Let's say you're building a custom UI and need to populate picklists based on the user's selected record type:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@AuraEnabled\npublic static Map<String, List<PicklistOption>> getPicklistsForRecordType(\n    String objectName, \n    String recordTypeId\n) {\n    Map<String, List<PicklistOption>> result = new Map<String, List<PicklistOption>>();\n    \n    // Get all picklist values for this record type\n    ConnectApi.PicklistValuesCollection picklistData = \n        ConnectApi.RecordUi.getPicklistValuesByRecordType(\n            objectName,\n            recordTypeId\n        );\n    \n    // Convert to a format your LWC can use\n    for (String fieldName : picklistData.picklistFieldValues.keySet()) {\n        List<PicklistOption> options = new List<PicklistOption>();\n        \n        ConnectApi.PicklistValues fieldValues = \n            picklistData.picklistFieldValues.get(fieldName);\n        \n        for (ConnectApi.PicklistValue pv : fieldValues.values) {\n            options.add(new PicklistOption(pv.label, pv.value));\n        }\n        \n        result.put(fieldName, options);\n    }\n    \n    return result;\n}\n\npublic class PicklistOption {\n    @AuraEnabled public String label;\n    @AuraEnabled public String value;\n    \n    public PicklistOption(String label, String value) {\n        this.label = label;\n        this.value = value;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Now your LWC gets all the picklist values it needs in one server call. No multiple round trips. No client-side filtering."
                    },
                    {
                        "type": "heading",
                        "value": "When to Use This"
                    },
                    {
                        "type": "text",
                        "value": "Use this method when:\n- You're building custom UIs that need record-type-specific picklists\n- You're working with dependent picklists and need the full dependency tree\n- You need to validate picklist values in Apex based on record type\n- You're migrating data and need to ensure values are valid for target record types"
                    },
                    {
                        "type": "heading",
                        "value": "What About LWC?"
                    },
                    {
                        "type": "text",
                        "value": "If you're in LWC, you already have getPicklistValuesByRecordType from the lightning/uiObjectInfoApi module. This new Apex method brings the same capability server-side. Use it when you need to process picklist logic in Apex rather than JavaScript."
                    },
                    {
                        "type": "heading",
                        "value": "The Gotchas"
                    },
                    {
                        "type": "text",
                        "value": "1. This is still in preview. Test it thoroughly before relying on it in production.\n2. The method returns ALL picklist fields for the object. If you only need one field, you're still getting all of them.\n3. For dependent picklists, you get all possible values. You still need to implement the filtering logic based on the controlling field.\n4. Available in Enterprise, Performance, Unlimited, and Developer editions only."
                    },
                    {
                        "type": "heading",
                        "value": "The Bottom Line"
                    },
                    {
                        "type": "text",
                        "value": "This is one of those quality-of-life improvements that should have existed years ago. No more callouts. No more workarounds. Just a clean, native way to get picklist values by record type."
                    },
                    {
                        "type": "text",
                        "value": "If you've been avoiding dependent picklists in custom UIs because of the complexity, give this a try. It's still in preview, but it's a game-changer for anyone building record-type-aware interfaces."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Extract Picklist Values Based on Record Type",
                                "url": "https://help.salesforce.com/s/articleView?id=release-notes.rn_apex_extract_picklist_values.htm&release=260&type=5"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "mock-callouts-testing",
                "title": "Mock Callouts: Testing Integrations Without the Internet",
                "date": "2026-01-08",
                "summary": "You can't make real HTTP callouts in Apex tests. Here's how to fake them properly.",
                "content": [
                    {
                        "type": "text",
                        "value": "Let's get this out of the way: you cannot make actual HTTP callouts in Apex test methods. Salesforce blocks them. Period. If you try, you'll get a 'Callout from triggers are currently not supported' error, even though you're not in a trigger."
                    },
                    {
                        "type": "text",
                        "value": "This is by design. Tests need to be fast, deterministic, and isolated. Real callouts are slow, unpredictable, and depend on external systems you don't control. So Salesforce forces you to mock them."
                    },
                    {
                        "type": "heading",
                        "value": "The Problem: Real Callouts Are Forbidden"
                    },
                    {
                        "type": "text",
                        "value": "Imagine you have an integration that calls an external API to validate addresses. In production, it works fine. But when you try to test it, the test fails because Salesforce won't let you make the HTTP request. Your code is correct, but you can't prove it."
                    },
                    {
                        "type": "text",
                        "value": "This is where HttpCalloutMock comes in. It's an interface that lets you fake HTTP responses without actually making network calls."
                    },
                    {
                        "type": "heading",
                        "value": "The Solution: HttpCalloutMock"
                    },
                    {
                        "type": "text",
                        "value": "The HttpCalloutMock interface has one method: respond(). You implement this method to return a fake HttpResponse. Salesforce intercepts your callout and uses your mock instead of hitting the network."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\npublic class AddressValidationMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        // Create a fake response\n        HttpResponse res = new HttpResponse();\n        res.setHeader('Content-Type', 'application/json');\n        res.setBody('{\"valid\": true, \"formatted\": \"123 Main St, San Francisco, CA 94105\"}');\n        res.setStatusCode(200);\n        return res;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Now in your test, you tell Salesforce to use this mock instead of making a real callout:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testAddressValidation() {\n    // Set the mock\n    Test.setMock(HttpCalloutMock.class, new AddressValidationMock());\n    \n    // Run your code that makes a callout\n    Test.startTest();\n    Boolean isValid = AddressService.validateAddress('123 Main St');\n    Test.stopTest();\n    \n    // Assert the result\n    Assert.isTrue(isValid, 'Address should be valid');\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Best Practice: Test Multiple Scenarios"
                    },
                    {
                        "type": "text",
                        "value": "Don't just test the happy path. Your integration needs to handle errors, timeouts, and unexpected responses. Create different mocks for different scenarios."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Mock for error response\n@isTest\npublic class AddressValidationErrorMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        HttpResponse res = new HttpResponse();\n        res.setStatusCode(500);\n        res.setBody('{\"error\": \"Service unavailable\"}');\n        return res;\n    }\n}\n\n// Mock for invalid address\n@isTest\npublic class AddressValidationInvalidMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        HttpResponse res = new HttpResponse();\n        res.setStatusCode(200);\n        res.setBody('{\"valid\": false, \"reason\": \"Address not found\"}');\n        return res;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Now you can test how your code handles failures:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testAddressValidationError() {\n    Test.setMock(HttpCalloutMock.class, new AddressValidationErrorMock());\n    \n    Test.startTest();\n    try {\n        AddressService.validateAddress('123 Main St');\n        Assert.fail('Should have thrown an exception');\n    } catch (AddressService.ValidationException e) {\n        Assert.isTrue(true, 'Exception caught as expected');\n    }\n    Test.stopTest();\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Advanced: Dynamic Mocks"
                    },
                    {
                        "type": "text",
                        "value": "Sometimes you need your mock to behave differently based on the request. Inspect the HttpRequest in your respond() method and return different responses accordingly."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\npublic class SmartAddressMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        HttpResponse res = new HttpResponse();\n        res.setHeader('Content-Type', 'application/json');\n        \n        // Check the request body\n        String body = req.getBody();\n        \n        if (body.contains('invalid-address')) {\n            res.setStatusCode(200);\n            res.setBody('{\"valid\": false}');\n        } else if (body.contains('error-trigger')) {\n            res.setStatusCode(500);\n            res.setBody('{\"error\": \"Internal error\"}');\n        } else {\n            res.setStatusCode(200);\n            res.setBody('{\"valid\": true}');\n        }\n        \n        return res;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "This lets you test multiple scenarios with a single mock class. Just vary your test data to trigger different responses."
                    },
                    {
                        "type": "heading",
                        "value": "Should You Centralize Your Mocks?"
                    },
                    {
                        "type": "text",
                        "value": "This depends on your codebase size and number of integrations."
                    },
                    {
                        "type": "heading",
                        "value": "Small Codebase (1-3 Integrations)"
                    },
                    {
                        "type": "text",
                        "value": "Keep mocks in the same file as your tests. It's simple, it's clear, and you don't need the overhead of a centralized system."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nprivate class AddressServiceTest {\n    // Mock class right here\n    private class SuccessMock implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) {\n            // ...\n        }\n    }\n    \n    @isTest\n    static void testValidation() {\n        Test.setMock(HttpCalloutMock.class, new SuccessMock());\n        // test logic\n    }\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Medium Codebase (4-10 Integrations)"
                    },
                    {
                        "type": "text",
                        "value": "Create a dedicated mock class for each integration. This keeps your test classes clean and makes mocks reusable across multiple test methods."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Dedicated mock class\n@isTest\npublic class AddressValidationMocks {\n    public class SuccessResponse implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) { /* ... */ }\n    }\n    \n    public class ErrorResponse implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) { /* ... */ }\n    }\n    \n    public class InvalidResponse implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) { /* ... */ }\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Now any test can use these mocks:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testSuccess() {\n    Test.setMock(HttpCalloutMock.class, new AddressValidationMocks.SuccessResponse());\n    // test logic\n}\n\n@isTest\nstatic void testError() {\n    Test.setMock(HttpCalloutMock.class, new AddressValidationMocks.ErrorResponse());\n    // test logic\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Large Codebase (10+ Integrations)"
                    },
                    {
                        "type": "text",
                        "value": "Build a mock factory. This is especially useful if you have multiple integrations with similar response patterns."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\npublic class HttpMockFactory {\n    public static HttpCalloutMock createSuccessMock(String body) {\n        return new GenericMock(200, body);\n    }\n    \n    public static HttpCalloutMock createErrorMock(Integer statusCode) {\n        return new GenericMock(statusCode, '{\"error\": \"Something went wrong\"}');\n    }\n    \n    private class GenericMock implements HttpCalloutMock {\n        private Integer statusCode;\n        private String body;\n        \n        public GenericMock(Integer statusCode, String body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n        \n        public HttpResponse respond(HttpRequest req) {\n            HttpResponse res = new HttpResponse();\n            res.setStatusCode(this.statusCode);\n            res.setBody(this.body);\n            res.setHeader('Content-Type', 'application/json');\n            return res;\n        }\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Usage is clean and declarative:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testIntegration() {\n    Test.setMock(\n        HttpCalloutMock.class, \n        HttpMockFactory.createSuccessMock('{\"status\": \"ok\"}')\n    );\n    // test logic\n}"
                    },
                    {
                        "type": "heading",
                        "value": "The Gotchas"
                    },
                    {
                        "type": "text",
                        "value": "1. Test.setMock() applies to ALL callouts in that test. If you make multiple callouts to different endpoints, you need a multi-endpoint mock or StaticResourceCalloutMock.\n2. Mocks don't validate your request. If your code sends malformed JSON, the mock will still return a response. You need to manually inspect req in your mock if validation matters.\n3. Don't hardcode production URLs in your mocks. Use Custom Metadata or Named Credentials so your tests don't break when endpoints change."
                    },
                    {
                        "type": "heading",
                        "value": "The Bottom Line"
                    },
                    {
                        "type": "text",
                        "value": "Mocking callouts isn't optional. It's the only way to test integrations in Apex. Start simple with inline mocks, then refactor to dedicated classes or factories as your codebase grows."
                    },
                    {
                        "type": "text",
                        "value": "And remember: test the failures, not just the happy path. Your integration will fail in production. Make sure your code handles it gracefully."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Testing HTTP Callouts",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_restful_http_testing.htm"
                            },
                            {
                                "title": "HttpCalloutMock Interface",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_interface_httpcalloutmock.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "typescript-lwc-preview",
                "title": "TypeScript in LWC: Finally, Type Safety for Your Components",
                "date": "2026-01-08",
                "summary": "TypeScript support is here (in developer preview). Here's why it matters and how to prepare for the rollout.",
                "content": [
                    {
                        "type": "text",
                        "value": "Let's be honest: JavaScript's lack of type safety has been a pain point in LWC development. You connect to Apex (strongly typed), you work with Salesforce objects (strongly typed), but your LWC code? Loosely typed JavaScript. Until now."
                    },
                    {
                        "type": "text",
                        "value": "Salesforce just released TypeScript support for LWC as a developer preview. This is huge. Let me explain why, and how you should prepare for when this hits GA."
                    },
                    {
                        "type": "heading",
                        "value": "Why TypeScript Matters for LWC"
                    },
                    {
                        "type": "text",
                        "value": "TypeScript is a superset of JavaScript that adds static typing. You write .ts files instead of .js files, and the TypeScript compiler checks your types at build time. This catches errors before they hit production."
                    },
                    {
                        "type": "heading",
                        "value": "The Apex Connection"
                    },
                    {
                        "type": "text",
                        "value": "Here's the killer benefit: Apex is strongly typed. When you call an Apex method from LWC, you're crossing a type boundary. In JavaScript, you have no idea what shape the data is. You just hope the Apex method returns what you expect."
                    },
                    {
                        "type": "text",
                        "value": "With TypeScript, you can define interfaces that match your Apex return types. Now your IDE knows what fields exist, what their types are, and it can autocomplete them. No more typos. No more 'undefined is not a function' errors."
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "// Define an interface matching your Apex class\ninterface Contact {\n    Id: string;\n    FirstName: string;\n    LastName: string;\n    Email: string;\n    Phone?: string;  // Optional field\n}\n\n// Your Apex method returns List<Contact>\nimport getContacts from '@salesforce/apex/ContactController.getContacts';\n\nexport default class ContactList extends LightningElement {\n    contacts: Contact[] = [];\n    \n    async loadContacts() {\n        this.contacts = await getContacts();\n        \n        // TypeScript knows 'contacts' is an array of Contact\n        // Autocomplete works. Type checking works.\n        this.contacts.forEach(contact => {\n            console.log(contact.FirstName);  // ✓ Valid\n            console.log(contact.InvalidField);  // ✗ Compile error\n        });\n    }\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Real-World Example: Wire Adapters"
                    },
                    {
                        "type": "text",
                        "value": "Wire adapters are notorious for unclear return types. With TypeScript, you can be explicit:"
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "import { LightningElement, wire } from 'lwc';\nimport { getRecord, GetRecordConfig } from 'lightning/uiRecordApi';\n\ninterface AccountRecord {\n    Id: string;\n    fields: {\n        Name: { value: string };\n        Industry: { value: string };\n        AnnualRevenue: { value: number | null };\n    };\n}\n\nexport default class AccountDetails extends LightningElement {\n    recordId: string = '001xx000003DGb2AAG';\n    account?: AccountRecord;\n    \n    @wire(getRecord, { \n        recordId: '$recordId', \n        fields: ['Account.Name', 'Account.Industry', 'Account.AnnualRevenue'] \n    })\n    wiredAccount({ data, error }: { data?: AccountRecord; error?: any }) {\n        if (data) {\n            this.account = data;\n            // TypeScript knows the shape of 'account'\n            const name = this.account.fields.Name.value;\n            const revenue = this.account.fields.AnnualRevenue.value ?? 0;\n        }\n    }\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Benefits Beyond Type Safety"
                    },
                    {
                        "type": "text",
                        "value": "1. **Autocomplete**: Your IDE knows what methods and properties exist. No more guessing.\n2. **Refactoring**: Rename a property? TypeScript updates all references. In JavaScript, you're doing find-and-replace and hoping you didn't miss anything.\n3. **Documentation**: Types are self-documenting. You don't need comments explaining what a function expects.\n4. **Catch Errors Early**: Typos, wrong types, missing properties, all caught at compile time, not runtime."
                    },
                    {
                        "type": "heading",
                        "value": "How to Set It Up (Developer Preview)"
                    },
                    {
                        "type": "text",
                        "value": "This is still in developer preview, so setup requires a few steps. First, enable the feature flag in VS Code settings:"
                    },
                    {
                        "type": "code",
                        "language": "json",
                        "value": "// .vscode/settings.json\n{\n    \"salesforcedx-vscode-lwc.preview.typeScriptSupport\": true\n}"
                    },
                    {
                        "type": "text",
                        "value": "This creates a tsconfig.json in your lwc folder. Then install TypeScript (minimum v5.4.5):"
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "npm install --save-dev typescript@5.4.5"
                    },
                    {
                        "type": "text",
                        "value": "Now you can create .ts files instead of .js files. But here's the catch: Salesforce doesn't compile TypeScript. You have to compile it yourself before deploying."
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "# Compile all TypeScript files to JavaScript\ntsc"
                    },
                    {
                        "type": "text",
                        "value": "This generates .js files alongside your .ts files. You deploy the JavaScript. The TypeScript stays in your source control."
                    },
                    {
                        "type": "heading",
                        "value": "The Decorator Workaround"
                    },
                    {
                        "type": "text",
                        "value": "There's a quirk. TypeScript's experimentalDecorators option must be set to false, but this causes TypeScript to complain about LWC decorators like @api, @track, and @wire."
                    },
                    {
                        "type": "text",
                        "value": "The workaround? Add // @ts-expect-error above each decorator:"
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "export default class MyComponent extends LightningElement {\n    // @ts-expect-error\n    @api recordId: string;\n    \n    // @ts-expect-error\n    @track privateData: any[] = [];\n    \n    // @ts-expect-error\n    @wire(getRecord, { recordId: '$recordId' })\n    wiredRecord({ data, error }: any) {\n        // ...\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "It's ugly, but temporary. Salesforce is working on fixing this before GA."
                    },
                    {
                        "type": "heading",
                        "value": "What's Missing (For Now)"
                    },
                    {
                        "type": "text",
                        "value": "This is a developer preview. Some things don't work yet:\n\n1. **Salesforce CLI integration**: You can't deploy TypeScript directly with sfdx or sf commands. You have to compile first.\n2. **Custom object types**: No auto-generated types for your custom Salesforce objects. You have to write interfaces manually.\n3. **Source map debugging**: You can't debug TypeScript in the browser. You're debugging the compiled JavaScript.\n4. **Limited type definitions**: Not all LWC modules have types yet. @salesforce/lightning-types is still growing."
                    },
                    {
                        "type": "heading",
                        "value": "How to Prepare for GA"
                    },
                    {
                        "type": "text",
                        "value": "Don't wait for GA to start learning TypeScript. Here's what you should do now:"
                    },
                    {
                        "type": "heading",
                        "value": "1. Learn TypeScript Basics"
                    },
                    {
                        "type": "text",
                        "value": "If you've never used TypeScript, start with the fundamentals. Interfaces, types, generics, union types. You don't need to be an expert, but you need to be comfortable."
                    },
                    {
                        "type": "heading",
                        "value": "2. Set Up a Test Project"
                    },
                    {
                        "type": "text",
                        "value": "Create a scratch org, enable the feature flag, and convert a simple component to TypeScript. Get familiar with the workflow: write .ts, compile to .js, deploy .js."
                    },
                    {
                        "type": "heading",
                        "value": "3. Define Interfaces for Your Apex Classes"
                    },
                    {
                        "type": "text",
                        "value": "Start documenting your Apex return types as TypeScript interfaces. When GA hits, you'll already have them ready."
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "// types/apex.ts\nexport interface OpportunityWrapper {\n    opportunity: {\n        Id: string;\n        Name: string;\n        StageName: string;\n        Amount: number;\n        CloseDate: string;\n    };\n    relatedContacts: Contact[];\n    lineItems: OpportunityLineItem[];\n}\n\nexport interface Contact {\n    Id: string;\n    FirstName: string;\n    LastName: string;\n    Email: string;\n}\n\nexport interface OpportunityLineItem {\n    Id: string;\n    ProductName: string;\n    Quantity: number;\n    UnitPrice: number;\n}"
                    },
                    {
                        "type": "heading",
                        "value": "4. Use Source Control"
                    },
                    {
                        "type": "text",
                        "value": "Salesforce doesn't store your TypeScript files. Only the compiled JavaScript gets deployed. You MUST use Git or another source control system. Add your .js files to .gitignore and only commit .ts files."
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "# .gitignore\n# Ignore compiled JavaScript (we only commit TypeScript)\nforce-app/main/default/lwc/**/*.js\nforce-app/main/default/lwc/**/*.js.map"
                    },
                    {
                        "type": "heading",
                        "value": "5. Plan Your Migration Strategy"
                    },
                    {
                        "type": "text",
                        "value": "You don't have to convert everything at once. Start with new components. Gradually migrate existing ones. TypeScript and JavaScript can coexist in the same project."
                    },
                    {
                        "type": "heading",
                        "value": "The Bottom Line"
                    },
                    {
                        "type": "text",
                        "value": "TypeScript in LWC is a game-changer. It brings the type safety you've been missing, especially when working with Apex. The developer preview has rough edges, but the core value is there."
                    },
                    {
                        "type": "text",
                        "value": "Start learning now. Set up a test project. Get comfortable with the workflow. When this hits GA, you'll be ready to migrate your components and finally have the type safety you deserve."
                    },
                    {
                        "type": "text",
                        "value": "And if you're already using TypeScript in other projects? You know exactly why this matters. Welcome to the future of LWC development."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "TypeScript Type Definitions for LWC (Developer Preview)",
                                "url": "https://developer.salesforce.com/docs/platform/lwc/guide/ts.html"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "es": {
        "articles": [
            {
                "id": "testing-and-quality",
                "title": "Las Pruebas no son para llenar casillas",
                "date": "2024-03-15",
                "summary": "Te mostraré por qué una buena suite de pruebas es lo único que se interpone entre tú y una caída de producción a las 3 AM.",
                "content": [
                    {
                        "type": "text",
                        "value": "Mira, lo entiendo. Acabas de pasar 8 horas construyendo un trigger complejo y ahora tienes que escribir cobertura de código. Es tentador escribir un `testMethod` que llame a tu código y no afirme nada, solo para llegar a ese 75%."
                    },
                    {
                        "type": "text",
                        "value": "No seas esa persona. Ese 75% no es una meta; es el mínimo indispensable. Cobertura no significa *calidad*."
                    },
                    {
                        "type": "heading",
                        "value": "La llamada de las 3 AM"
                    },
                    {
                        "type": "text",
                        "value": "Una vez desplegué una funcionalidad 'perfecta'. Dos semanas después, una regla de validación la rompió. Como no validé mis resultados esperados, el sistema falló silenciosamente hasta que un VP intentó cerrar un trato. Créeme, no quieres recibir esa llamada."
                    },
                    {
                        "type": "heading",
                        "value": "Preparar, Actuar, Afirmar"
                    },
                    {
                        "type": "text",
                        "value": "Esta es la santísima trinidad. Prepara tus datos (Arrange), ejecuta tu código (Act), y luego, lo más importante, prueba que hizo lo que se suponía que debía hacer (Assert)."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nprivate class AccountTriggerTest {\n    @isTest\n    static void shouldUpdateOpportunitiesOnAccountClosure() {\n        // Arrange: datos válidos\n        Account testAcc = new Account(Name = 'Test Account');\n        insert testAcc;\n        \n        // Act: haz la cosa\n        Test.startTest();\n        testAcc.Status__c = 'Closed';\n        update testAcc;\n        Test.stopTest();\n        \n        // Assert: PRUEBA que funcionó\n        Opportunity updatedOpp = [SELECT StageName FROM Opportunity WHERE Id = :testOpp.Id];\n        Assert.areEqual('Closed Lost', updatedOpp.StageName, 'Opportunity NO cerrada? Arréglalo.');\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Si no estás usando `Assert.areEqual`, no estás probando. Estás desperdiciando espacio."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Assert Class",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Assert.htm"
                            },
                            {
                                "title": "Testing Best Practices",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_best_practices.htm"
                            },
                            {
                                "title": "Testing Apex",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing.htm"
                            },
                            {
                                "title": "Testing Example",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_testing_example.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "automation",
                "title": "Flow es Poderoso (Pero Úsalo Sabiamente)",
                "date": "2026-01-05",
                "summary": "Aprende cuándo usarlo, cuándo programar y cómo evitar introducir complejidad innecesaria.",
                "content": [
                    {
                        "type": "text",
                        "value": "Me gusta Flow. Es democrático, es visual y permite a los Admins hacer cosas que solían requerir una semana de mi tiempo. Pero un gran poder conlleva una gran capacidad para destruir una org por completo."
                    },
                    {
                        "type": "heading",
                        "value": "La Trampa del 'No-Code'"
                    },
                    {
                        "type": "text",
                        "value": "Solo porque *puedes* construirlo en Flow no significa que *debas*. Si veo un Flow con 50 elementos solo para iterar una colección y actualizar registros, rechazaré ese Pull Request. ¿Por qué? Porque 5 líneas de Apex son más rápidas, limpias y fáciles de depurar."
                    },
                    {
                        "type": "heading",
                        "value": "No Alimentes al Monstruo de Espagueti"
                    },
                    {
                        "type": "text",
                        "value": "Arrastrar y soltar es divertido hasta que tienes un lienzo que parece un plato de fideos tirado al suelo. Si no puedes explicar la lógica de tu Flow en 3 oraciones, es demasiado complejo. Divídelo. Usa Subflows. O mejor aún, usa Invocable Apex."
                    },
                    {
                        "type": "heading",
                        "value": "La Regla de Oro"
                    },
                    {
                        "type": "text",
                        "value": "Un Record-Triggered Flow por Objeto. No me importa lo que digan las nuevas funcionalidades. Si tienes 5 flows diferentes disparándose en la actualización de Oportunidad, no tienes una arquitectura; tienes una condición de carrera esperando suceder."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Flow Builder Best Practices",
                                "url": "https://help.salesforce.com/s/articleView?id=sf.flow_prep_bestpractices.htm"
                            },
                            {
                                "title": "Automation with Flow",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.salesforce_vpm_guide.meta/salesforce_vpm_guide/vpm_intro.htm"
                            },
                            {
                                "title": "When to Use Flow vs Apex",
                                "url": "https://architect.salesforce.com/decision-guides/trigger-automation"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "debugging",
                "title": "Depuración: CSI Salesforce",
                "date": "2026-01-05",
                "summary": "Producción está caída. Todos gritan. No entres en pánico. Ponte tu sombrero de detective y miremos los logs.",
                "content": [
                    {
                        "type": "text",
                        "value": "Tu teléfono vibra. Los usuarios reciben un 'Script-Thrown Exception'. Tu adrenalina se dispara. Detente. Respira."
                    },
                    {
                        "type": "heading",
                        "value": "La Escena del Crimen (Logs)"
                    },
                    {
                        "type": "text",
                        "value": "Los logs de Salesforce son notoriamente feos. Son enormes, verbosos e intimidantes. Pero la verdad está ahí. Busca `USER_DEBUG` o `EXCEPTION_THROWN`. Ignora el ruido."
                    },
                    {
                        "type": "heading",
                        "value": "Reproduce el Crimen"
                    },
                    {
                        "type": "text",
                        "value": "Si no puedes reproducirlo, no puedes arreglarlo. No despliegues ciegamente un 'arreglo' esperando que funcione. Necesitas verificar el bug en un Sandbox primero. Mismos datos, mismo usuario, mismos pasos."
                    },
                    {
                        "type": "heading",
                        "value": "Checkpoints"
                    },
                    {
                        "type": "text",
                        "value": "¿No puedes agregar `System.debug` en Producción? Usa Checkpoints en la Developer Console. Te permiten inspeccionar la memoria en una línea específica de código sin desplegar cambios. Es magia."
                    },
                    {
                        "type": "text",
                        "value": "¿Y cuando todo lo demás falla? Rubber Duck Debugging (Depuración con Patito de Hule). Explica tu código línea por línea a un objeto inanimado. Te sorprenderá, con qué frecuencia encuentras el error tú mismo."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Debug Log Basics",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_debugging_debug_log.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "careers",
                "title": "La Mentalidad Senior: No es Solo Sobre Código",
                "date": "2026-01-05",
                "summary": "Hablemos de las 'Habilidades Blandas' que en realidad son duras.",
                "content": [
                    {
                        "type": "text",
                        "value": "Solía pensar que ser un Desarrollador Senior significaba conocer cada detalle oscuro del compilador interno de Apex. Estaba equivocado."
                    },
                    {
                        "type": "heading",
                        "value": "El Cambio"
                    },
                    {
                        "type": "text",
                        "value": "Un Desarrollador Junior pregunta: '¿Cómo construyo esto?' Un Desarrollador Senior pregunta: '¿Deberíamos construir esto?' Tu trabajo no es solo escribir código; es resolver problemas. A veces la mejor línea de código es la que no escribiste porque convenciste al stakeholder de usar funcionalidad estándar."
                    },
                    {
                        "type": "heading",
                        "value": "El Poder del 'No'"
                    },
                    {
                        "type": "text",
                        "value": "Proteger tu org es tu deber principal. Cuando llega una solicitud que sabes que creará deuda técnica, tienes que decir no. Pero no solo digas 'No'. Di 'No, pero aquí hay una mejor manera'."
                    },
                    {
                        "type": "heading",
                        "value": "Propiedad (Ownership)"
                    },
                    {
                        "type": "text",
                        "value": "Cuando Producción se rompe a las 5 PM un viernes, un Junior busca a un Gerente. Un Senior busca los logs. Propiedad significa que tratas el código como tuyo, incluso el espagueti legado que no escribiste."
                    },
                    {
                        "type": "heading",
                        "value": "Mentoría"
                    },
                    {
                        "type": "text",
                        "value": "No has dominado un concepto hasta que puedes explicárselo a un Junior sin hacerlo sentir estúpido. Eleva a los demás. Esa es la verdadera marca de la antigüedad."
                    }
                ]
            },
            {
                "id": "pagination-cursors",
                "title": "Cursores de Paginación: El Fin de las Pesadillas con OFFSET",
                "date": "2026-01-06",
                "summary": "Hay una nueva funcionalidad beta que va a cambiar cómo manejas grandes conjuntos de datos.",
                "content": [
                    {
                        "type": "text",
                        "value": "Necesito contarte sobre una funcionalidad beta que está saliendo silenciosamente. Si alguna vez alcanzaste el límite de OFFSET, escribiste paginación frágil basada en IDs, o iniciaste Batch Apex solo para procesar 10,000 registros, esto es para ti."
                    },
                    {
                        "type": "heading",
                        "value": "La Forma Antigua Era Dolorosa"
                    },
                    {
                        "type": "text",
                        "value": "Seamos honestos. OFFSET tiene un máximo de 2,000 filas y se vuelve más lento mientras más profundo vas. La paginación basada en ID ('WHERE Id > :lastId') funciona, pero es frágil y se rompe si se eliminan registros. ¿Y Batch Apex? Es poderoso, pero es como usar una excavadora para mover un sofá."
                    },
                    {
                        "type": "heading",
                        "value": "Entra: PaginationCursor"
                    },
                    {
                        "type": "text",
                        "value": "Salesforce ahora te permite pausar y reanudar una consulta SOQL sin re-ejecutarla. La plataforma rastrea tu posición por ti. Así se ve:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "Integer pageSize = 200;\n\nDatabase.QueryLocator locator = Database.getQueryLocator(\n    'SELECT Id, Name FROM Account ORDER BY CreatedDate'\n);\n\nPaginationCursor cursor = locator.getPaginationCursor();\nList<Account> page = locator.fetch(pageSize);\n\nwhile (!page.isEmpty()) {\n    // Procesa tus registros\n    for (Account acc : page) {\n        System.debug(acc.Name);\n    }\n    \n    // Obtén la siguiente página\n    page = locator.fetch(pageSize);\n}"
                    },
                    {
                        "type": "text",
                        "value": "Sin OFFSET. Sin rastreo manual de IDs. Solo obtén el siguiente bloque."
                    },
                    {
                        "type": "heading",
                        "value": "La Funcionalidad 'Killer': Serialización"
                    },
                    {
                        "type": "text",
                        "value": "Aquí es donde se pone bueno. Puedes serializar el cursor, almacenarlo y reanudarlo después. Perfecto para integraciones de larga duración o trabajos asíncronos que podrían interrumpirse."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Almacénalo\nString cursorState = JSON.serialize(cursor);\n// Guarda en Custom Object, Platform Cache, etc.\n\n// Reanuda después\nPaginationCursor cursor = (PaginationCursor) JSON.deserialize(\n    cursorState,\n    PaginationCursor.class\n);"
                    },
                    {
                        "type": "heading",
                        "value": "Cuándo Usarlo"
                    },
                    {
                        "type": "text",
                        "value": "Usa cursores para: procesamiento backend, trabajos asíncronos, migraciones de datos grandes. No los uses para: paginación UI en tiempo real en LWC o Visualforce. Y siempre incluye una cláusula ORDER BY determinística, los cursores necesitan ordenamiento consistente."
                    },
                    {
                        "type": "text",
                        "value": "Esto todavía está en beta, así que prueba exhaustivamente. Pero si estás cansado de los hacks de OFFSET y la complejidad de Batch Apex, dale una oportunidad a PaginationCursor. Es una de esas funcionalidades que simplemente tiene sentido."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Use Apex Cursors for Expanded SOQL Query Result Support (Generally Available)",
                                "url": "https://help.salesforce.com/s/articleView?id=release-notes.rn_apex_cursors.htm&release=260&type=5"
                            },
                            {
                                "title": "SOQL Query Limits",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.soql_sosl.meta/soql_sosl/sforce_api_calls_soql_select_offset.htm"
                            },
                            {
                                "title": "Batch Apex vs Pagination Cursors",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_batch.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "lwc-communication",
                "title": "Hablando con tus Componentes: Props Bajan, Eventos Suben",
                "date": "2026-01-06",
                "summary": "Aprende la regla de oro de LWC: los datos fluyen hacia abajo vía props, los eventos burbujean hacia arriba. Es más simple de lo que piensas.",
                "content": [
                    {
                        "type": "text",
                        "value": "Si has construido algo más que un 'Hola Mundo' en LWC, te has topado con esto: ¿cómo paso datos entre componentes? La respuesta es hermosamente simple. Los props bajan, los eventos suben. Eso es todo. Domina este patrón y construirás componentes más limpios y componibles."
                    },
                    {
                        "type": "heading",
                        "value": "Props: El Padre Controla al Hijo"
                    },
                    {
                        "type": "text",
                        "value": "Piensa en los props como parámetros de una función. El padre los proporciona, el hijo los recibe. En LWC, haces una propiedad pública usando el decorador @api. Esa es tu señal: 'Hey, los componentes padres pueden configurar esto'."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// childComponent.js\nimport { LightningElement, api } from 'lwc';\n\nexport default class ChildComponent extends LightningElement {\n    @api recordName;  // Propiedad pública\n    @api isActive = false;  // Pública con valor por defecto\n}"
                    },
                    {
                        "type": "text",
                        "value": "Ahora el padre puede pasar datos mediante atributos, tal como pasarías argumentos a una función:"
                    },
                    {
                        "type": "code",
                        "language": "html",
                        "value": "<!-- parentComponent.html -->\n<template>\n    <c-child-component \n        record-name={contactName}\n        is-active={status}>\n    </c-child-component>\n</template>"
                    },
                    {
                        "type": "text",
                        "value": "¿Notas el kebab-case en HTML (record-name) vs camelCase en JavaScript (recordName)? Son estándares web. LWC los sigue religiosamente."
                    },
                    {
                        "type": "heading",
                        "value": "La Calle de Un Solo Sentido"
                    },
                    {
                        "type": "text",
                        "value": "Los props fluyen HACIA ABAJO solamente. El hijo no puede, y no debe, mutar el valor de un prop. Si intentas reasignar this.recordName en el hijo, estás rompiendo el contrato. El padre es dueño de los datos. El hijo los muestra."
                    },
                    {
                        "type": "heading",
                        "value": "Eventos: El Hijo Informa al Padre"
                    },
                    {
                        "type": "text",
                        "value": "Entonces, si el hijo no puede cambiar los props, ¿cómo se comunica de vuelta? Eventos. Cuando algo sucede en el hijo que el padre necesita saber, dispara un evento. El padre escucha y decide qué hacer."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// childComponent.js\nimport { LightningElement } from 'lwc';\n\nexport default class ChildComponent extends LightningElement {\n    handleClick() {\n        // Crea el evento\n        const event = new CustomEvent('select', {\n            detail: { recordId: this.recordId }\n        });\n        \n        // Despáchalo\n        this.dispatchEvent(event);\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Los nombres de eventos deben estar en minúsculas, sin espacios, usa guiones bajos si necesitas múltiples palabras. Y nunca uses el prefijo 'on', eso crea confusión en el marcado."
                    },
                    {
                        "type": "heading",
                        "value": "El Padre Escucha"
                    },
                    {
                        "type": "text",
                        "value": "El componente padre escucha usando la sintaxis onEventName. Como nuestro evento se llama 'select', usamos onselect:"
                    },
                    {
                        "type": "code",
                        "language": "html",
                        "value": "<!-- parentComponent.html -->\n<template>\n    <c-child-component \n        onselect={handleSelection}>\n    </c-child-component>\n</template>"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// parentComponent.js\nimport { LightningElement } from 'lwc';\n\nexport default class ParentComponent extends LightningElement {\n    handleSelection(event) {\n        const recordId = event.detail.recordId;\n        // Haz algo con los datos\n        console.log('Registro seleccionado:', recordId);\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "¿Los datos que pasaste en la propiedad 'detail'? Así es como los accedes: event.detail. Simple."
                    },
                    {
                        "type": "heading",
                        "value": "La Propiedad Detail: Envía Primitivos"
                    },
                    {
                        "type": "text",
                        "value": "Aquí hay una trampa. JavaScript pasa objetos por referencia. Si envías un objeto en event.detail y el padre lo muta, acabas de cambiar los datos del hijo sin su conocimiento. Malo.\n\nMantente con primitivos (strings, números, booleanos) en tu payload de detail. Si debes enviar un objeto, clónalo primero usando la sintaxis spread u Object.assign()."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// BIEN: Enviando primitivos\nconst event = new CustomEvent('update', {\n    detail: { id: this.recordId, name: this.name }\n});\n\n// ACEPTABLE: Clonando un objeto\nconst event = new CustomEvent('update', {\n    detail: { ...this.recordData }\n});"
                    },
                    {
                        "type": "heading",
                        "value": "Ejemplo del Mundo Real"
                    },
                    {
                        "type": "text",
                        "value": "Digamos que estás construyendo una lista de contactos. El padre (c-contact-list) administra la lista. Cada hijo (c-contact-tile) muestra un contacto. Cuando un usuario hace clic en un tile, el padre necesita saber qué contacto fue seleccionado."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// contactTile.js (HIJO)\nimport { LightningElement, api } from 'lwc';\n\nexport default class ContactTile extends LightningElement {\n    @api contact;  // El padre pasa el contacto\n\n    handleClick() {\n        const selectEvent = new CustomEvent('contactselect', {\n            detail: { contactId: this.contact.Id }\n        });\n        this.dispatchEvent(selectEvent);\n    }\n}"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// contactList.js (PADRE)\nimport { LightningElement, wire } from 'lwc';\nimport getContacts from '@salesforce/apex/ContactController.getContacts';\n\nexport default class ContactList extends LightningElement {\n    selectedContactId;\n    @wire(getContacts) contacts;\n\n    handleContactSelect(event) {\n        this.selectedContactId = event.detail.contactId;\n        // Ahora obtén detalles, actualiza la UI, etc.\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Al hijo no le importa ni sabe qué hace el padre con el evento. Quizás muestra detalles. Quizás activa una navegación. No importa. El trabajo del hijo está hecho: anunció que algo sucedió."
                    },
                    {
                        "type": "heading",
                        "value": "Por Qué Esto Importa"
                    },
                    {
                        "type": "text",
                        "value": "Este patrón mantiene tus componentes desacoplados. El componente hijo es reutilizable. Colócalo donde sea, escucha sus eventos, y listo. Sin acoplamiento estrecho. Sin referencias al padre. Solo código limpio y componible.\n\nProps bajan. Eventos suben. Es el camino de LWC. Aprende esto, y tus componentes te lo agradecerán."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Communicate with Events",
                                "url": "https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.events"
                            },
                            {
                                "title": "Public Properties",
                                "url": "https://developer.salesforce.com/docs/platform/lwc/guide/reactivity-public.html"
                            },
                            {
                                "title": "Create and Dispatch Events",
                                "url": "https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.events_create_dispatch"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "lwc-decorators",
                "title": "Decoradores: Los Símbolos @ Mágicos que Realmente Importan",
                "date": "2026-01-06",
                "summary": "Deja de usar @track en cada campo sin razón. Aprende qué hacen realmente @api, @wire y @track, y cuándo realmente los necesitas.",
                "content": [
                    {
                        "type": "text",
                        "value": "Veo esto todo el tiempo en revisiones de código: cada campo decorado con @track. Cuando pregunto por qué, la respuesta siempre es 'para hacerlo reactivo.' Incorrecto. Desde Spring '20, todos los campos son reactivos por defecto. Solo estás agregando ruido."
                    },
                    {
                        "type": "heading",
                        "value": "Los Tres Mosqueteros"
                    },
                    {
                        "type": "text",
                        "value": "LWC te da tres decoradores. Cada uno tiene un propósito específico. Usa el incorrecto, o úsalos en exceso, y estarás haciendo tu código más difícil de leer sin ningún beneficio."
                    },
                    {
                        "type": "heading",
                        "value": "@api: El Contrato Público"
                    },
                    {
                        "type": "text",
                        "value": "Usa @api cuando quieres que una propiedad o método sea accesible desde fuera del componente. Esta es la API pública de tu componente. Los componentes padres pueden establecer estas propiedades. Otro código puede llamar estos métodos."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "import { LightningElement, api } from 'lwc';\n\nexport default class MyComponent extends LightningElement {\n    @api recordId;  // El padre puede configurar esto\n    @api itemName;  // Propiedad pública\n    \n    @api refresh() {  // Método público\n        // El padre puede llamar esto\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Si no lo estás exponiendo a un padre o usándolo en App Builder, no uses @api. Así de simple."
                    },
                    {
                        "type": "heading",
                        "value": "@wire: Datos Reactivos de Salesforce"
                    },
                    {
                        "type": "text",
                        "value": "@wire conecta tu componente a datos de Salesforce. Úsalo con Lightning Data Service (LDS) o métodos Apex. El framework actualiza automáticamente tu componente cuando los datos subyacentes cambian."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "import { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n\nexport default class RecordViewer extends LightningElement {\n    @api recordId;\n    \n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    record;\n}"
                    },
                    {
                        "type": "text",
                        "value": "Cuando recordId cambia, el wire adapter automáticamente vuelve a obtener los datos. Sin llamadas manuales. Sin lifecycle hooks. Simplemente funciona."
                    },
                    {
                        "type": "heading",
                        "value": "@track: El Incomprendido"
                    },
                    {
                        "type": "text",
                        "value": "Aquí es donde todos se equivocan. Antes de Spring '20, necesitabas @track para hacer los campos reactivos. Ya no. Todos los campos son reactivos ahora."
                    },
                    {
                        "type": "text",
                        "value": "NO uses @track en primitivos. No hace nada. Esto es inútil:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// MAL: Innecesario\n@track firstName = '';  // String ya es reactivo\n@track count = 0;       // Number ya es reactivo\n@track isActive = false; // Boolean ya es reactivo"
                    },
                    {
                        "type": "text",
                        "value": "¿Entonces cuándo usas @track? Solo cuando necesitas observar cambios en el INTERIOR de un objeto o array."
                    },
                    {
                        "type": "heading",
                        "value": "Cuándo @track Importa: Objetos"
                    },
                    {
                        "type": "text",
                        "value": "Digamos que tienes un objeto y estás cambiando una propiedad dentro de él, no reasignando el objeto completo. Sin @track, el framework no detectará el cambio."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// SIN @track\nuser = { firstName: 'John', lastName: 'Doe' };\n\nhandleClick() {\n    // Esto NO activará un rerender\n    this.user.firstName = 'Jane';\n}"
                    },
                    {
                        "type": "text",
                        "value": "¿Por qué? Porque la referencia del objeto user no cambió. Sigue siendo el mismo objeto. El framework compara usando ===, y user === user es verdadero."
                    },
                    {
                        "type": "text",
                        "value": "Dos soluciones. O reasigna el objeto completo:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// Solución 1: Reasignar el objeto completo\nhandleClick() {\n    this.user = { ...this.user, firstName: 'Jane' };\n    // Ahora user es un objeto NUEVO, el framework detecta el cambio\n}"
                    },
                    {
                        "type": "text",
                        "value": "O usa @track para decirle al framework que observe el interior:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// Solución 2: Usar @track\n@track user = { firstName: 'John', lastName: 'Doe' };\n\nhandleClick() {\n    this.user.firstName = 'Jane';  // AHORA renderiza\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Cuándo @track Importa: Arrays"
                    },
                    {
                        "type": "text",
                        "value": "Mismo problema con arrays. Si haces push, pop, o modificas elementos sin reasignar el array, el framework no lo detectará. A menos que uses @track."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// SIN @track\nitems = ['Apple', 'Banana'];\n\naddItem() {\n    this.items.push('Cherry');  // NO renderizará\n}"
                    },
                    {
                        "type": "text",
                        "value": "Soluciones: reasignar o @track."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// Solución 1: Reasignar\naddItem() {\n    this.items = [...this.items, 'Cherry'];\n}\n\n// Solución 2: Usar @track\n@track items = ['Apple', 'Banana'];\n\naddItem() {\n    this.items.push('Cherry');  // AHORA funciona\n}"
                    },
                    {
                        "type": "heading",
                        "value": "@track No Funciona en Todo"
                    },
                    {
                        "type": "text",
                        "value": "Advertencia importante: @track solo funciona en objetos planos ({}) y arrays ([]). NO funciona en instancias de clases, Date, Set, o Map."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "// Esto NO funcionará incluso con @track\n@track myDate = new Date();\n\nchangeDate() {\n    this.myDate.setFullYear(2025);  // NO observado\n}"
                    },
                    {
                        "type": "text",
                        "value": "Para objetos complejos como Date, siempre reasigna:"
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "changeDate() {\n    const newDate = new Date(this.myDate);\n    newDate.setFullYear(2025);\n    this.myDate = newDate;  // La reasignación activa el rerender\n}"
                    },
                    {
                        "type": "heading",
                        "value": "El Árbol de Decisión"
                    },
                    {
                        "type": "text",
                        "value": "Así es como decidir:\n\n1. ¿Un padre necesita configurarlo? → @api\n2. ¿Viene de Salesforce vía LDS o Apex? → @wire\n3. ¿Es un primitivo (string, number, boolean)? → No se necesita decorador\n4. ¿Es un objeto/array y mutas el interior? → @track O reasignar\n5. ¿Todo lo demás? → Sin decorador"
                    },
                    {
                        "type": "heading",
                        "value": "Ejemplo del Mundo Real"
                    },
                    {
                        "type": "text",
                        "value": "Digamos que estás construyendo un componente de carrito de compras."
                    },
                    {
                        "type": "code",
                        "language": "javascript",
                        "value": "import { LightningElement, api, track } from 'lwc';\n\nexport default class ShoppingCart extends LightningElement {\n    @api cartId;  // El padre establece esto\n    \n    @track items = [];  // Haremos push/pop de items\n    \n    totalPrice = 0;  // Primitivo, no se necesita decorador\n    \n    addItem(item) {\n        this.items.push(item);  // @track hace esto reactivo\n        this.totalPrice += item.price;  // Reasignación primitiva\n    }\n    \n    removeItem(index) {\n        this.items.splice(index, 1);  // @track observa esto\n        this.recalculateTotal();\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Nota: @api para propiedades públicas, @track para el array que mutamos, y sin decorador para el primitivo totalPrice."
                    },
                    {
                        "type": "heading",
                        "value": "Deja de Decorar Todo"
                    },
                    {
                        "type": "text",
                        "value": "¿El error más grande? Poner @track en cada campo 'por si acaso.' Es desorden de código. Le indica a otros desarrolladores que no entiendes la reactividad.\n\nUsa decoradores intencionalmente. Cada símbolo @ debe tener una razón. Si no puedes explicar por qué lo usaste, probablemente no deberías haberlo hecho."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "LWC Decorators Reference",
                                "url": "https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_decorators"
                            },
                            {
                                "title": "Reactivity in LWC",
                                "url": "https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_reactivity"
                            },
                            {
                                "title": "Understand the Wire Service",
                                "url": "https://developer.salesforce.com/docs/platform/lwc/guide/data-wire-service-about.html"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "clean-coder-lessons",
                "title": "Acabo de Terminar 'The Clean Coder.' Esto es lo que Realmente Resonó.",
                "date": "2026-01-06",
                "summary": "Estas son las lecciones que estoy intentando aplicar, no porque sean nuevas, sino porque finalmente entiendo por qué importan.",
                "content": [
                    {
                        "type": "text",
                        "value": "Seré honesto: agarré 'The Clean Coder' esperando hojearlo. Llevo años haciendo esto. ¿Cuánto podría realmente enseñarme Robert Martin sobre profesionalismo? Resulta que mucho. No porque no conociera estas cosas intelectualmente, sino porque no las había estado viviendo."
                    },
                    {
                        "type": "heading",
                        "value": "Decir No es una Habilidad, No Insubordinación"
                    },
                    {
                        "type": "text",
                        "value": "Esta me dolió. ¿Cuántas veces he dicho 'sí' a un plazo irreal solo para evitar conflictos? El punto de Martin es claro: decir 'sí' cuando deberías decir 'no' no es ser un jugador de equipo, es mentir."
                    },
                    {
                        "type": "text",
                        "value": "Si un gerente pide una funcionalidad para el viernes y sabes que tomará dos semanas, decir 'lo intentaré' está preparando a todos para el fracaso. La respuesta profesional es 'No, pero puedo tenerlo en dos semanas.' Y luego negocias."
                    },
                    {
                        "type": "text",
                        "value": "Estoy trabajando en esto. Es incómodo. Pero una promesa incumplida daña al equipo más que un 'no' honesto jamás podría."
                    },
                    {
                        "type": "heading",
                        "value": "Tú Eres Dueño de tu Carrera, No tu Empleador"
                    },
                    {
                        "type": "text",
                        "value": "Martin martilla esto: tu empleador te debe un sueldo, no una carrera. Si no estás dedicando tiempo fuera del trabajo manteniendo tus habilidades afiladas, te estás quedando atrás. Y eso es tu responsabilidad."
                    },
                    {
                        "type": "text",
                        "value": "Veinte horas a la semana suena extremo, pero el punto no es el número. Es la mentalidad. Lee. Practica. Construye cosas que no van a producción. Aprende ese nuevo framework antes de que el proyecto lo demande."
                    },
                    {
                        "type": "text",
                        "value": "Solía pensar '¿Programo todo el día, no es suficiente?' No. Las cosas que construyo en el trabajo ejercitan músculos viejos. Los proyectos personales y la práctica deliberada construyen nuevos."
                    },
                    {
                        "type": "heading",
                        "value": "Las Pruebas No Son Opcionales"
                    },
                    {
                        "type": "text",
                        "value": "Este no es un consejo nuevo, pero el enfoque de Martin me golpeó: si no pruebas tu código, ¿cómo sabes que funciona? 'Funcionó en mi máquina' no es profesionalismo. Es esperanza."
                    },
                    {
                        "type": "text",
                        "value": "He estado escribiendo pruebas para cobertura, no para confianza. Ese es el problema. Las pruebas deberían hacerme estar seguro de que el código funciona, no solo marcar una casilla para el despliegue."
                    },
                    {
                        "type": "text",
                        "value": "Ahora estoy intentando escribir las pruebas primero, no religiosamente TDD, pero lo suficiente para pensar en la API antes de escribir la implementación. Es más lento al inicio. Es más rápido en general."
                    },
                    {
                        "type": "heading",
                        "value": "Reconoce Cuándo Estás Cansado"
                    },
                    {
                        "type": "text",
                        "value": "Martin habla sobre la sesión de debugging a las 3 AM que crea más bugs de los que arregla. He vivido esto. Piensas que estás siendo dedicado. En realidad estás siendo imprudente."
                    },
                    {
                        "type": "text",
                        "value": "El código escrito mientras estás exhausto es código que borrarás en la mañana. Aléjate. Duerme. El problema seguirá ahí, pero tu cerebro realmente funcionará."
                    },
                    {
                        "type": "text",
                        "value": "Esto aplica también a las reuniones. Si estás desconectado en una sesión de planificación porque estás quemado, no estás ayudando. Eres un cuerpo tibio ocupando espacio."
                    },
                    {
                        "type": "heading",
                        "value": "Practica Como un Atleta"
                    },
                    {
                        "type": "text",
                        "value": "Los atletas no solo juegan partidos. Hacen drills. Practican. ¿Por qué nosotros no? Martin sugiere code katas, ejercicios pequeños que repites para construir memoria muscular."
                    },
                    {
                        "type": "text",
                        "value": "Probé esto. Implementar un algoritmo simple múltiples veces, probando diferentes enfoques. Se sintió tonto al principio. Luego me di cuenta: estaba aprendiendo patrones sin la presión de un plazo."
                    },
                    {
                        "type": "text",
                        "value": "Cuando un problema similar apareció en el trabajo, no tuve que pensar. Mis manos sabían qué hacer. Ese es el punto."
                    },
                    {
                        "type": "heading",
                        "value": "La Estimación No Es un Compromiso"
                    },
                    {
                        "type": "text",
                        "value": "Solía tratar las estimaciones como promesas. El gerente pregunta cuánto tomará algo, digo tres días, luego me mato para lograr tres días incluso cuando la realidad dice cinco."
                    },
                    {
                        "type": "text",
                        "value": "El consejo de Martin: da un rango. 'Mejor caso: tres días. Peor caso: una semana. Más probable: cinco días.' Y luego cúmplelo. Si descubres nueva complejidad, actualiza la estimación. No solo trabajes fines de semana para preservar tu suposición original."
                    },
                    {
                        "type": "text",
                        "value": "Las estimaciones son probabilidades, no contratos. Tratarlas como contratos solo significa que estarás equivocado y exhausto."
                    },
                    {
                        "type": "heading",
                        "value": "El Código No es Tuyo"
                    },
                    {
                        "type": "text",
                        "value": "El ego en code review es veneno. Alguien señala una mejor manera de hacer algo, y el instinto es defensividad. 'Pero mi forma funciona.' Claro. Y su forma funciona mejor."
                    },
                    {
                        "type": "text",
                        "value": "El punto de Martin: tú no eres tu código. La crítica de tu código no es crítica a ti. Es un regalo. Alguien acaba de mejorar tu trabajo gratis."
                    },
                    {
                        "type": "text",
                        "value": "Estoy intentando replantear esto. Cuando un dev junior encuentra un bug que me perdí, eso no es vergonzoso. Eso es el sistema funcionando. La revisión por pares lo atrapó antes de que producción lo hiciera."
                    },
                    {
                        "type": "heading",
                        "value": "Lo que Realmente Estoy Cambiando"
                    },
                    {
                        "type": "text",
                        "value": "Leer el libro es fácil. Aplicarlo es difícil. Esto es a lo que me estoy comprometiendo:\n\n1. Decir 'no' cuando quiero decir no. Negociar, no capitular.\n2. Apartar tiempo cada semana para práctica deliberada. No solo 'aprender en el trabajo.'\n3. Escribir pruebas que me den confianza, no solo cobertura.\n4. Alejarme cuando estoy demasiado cansado para pensar.\n5. Tratar las estimaciones como pronósticos, no promesas.\n6. Dejar mi ego en la puerta en las revisiones de código."
                    },
                    {
                        "type": "text",
                        "value": "Nada de esto es revolucionario. Pero leer a Martin decirlo, respaldado por décadas de historias de guerra, hizo que hiciera clic."
                    },
                    {
                        "type": "text",
                        "value": "No soy un profesional perfecto. Pero estoy trabajando en ello. Y ese es el punto."
                    }
                ]
            },
            {
                "id": "run-relevant-tests",
                "title": "RunRelevantTests: Despliega Más Rápido Sin la Espera",
                "date": "2026-01-08",
                "summary": "Aquí te cuento qué hace RunRelevantTests y por qué debería importarte.",
                "content": [
                    {
                        "type": "text",
                        "value": "Hablemos del dolor de los despliegues. Cambias un trigger. Uno. Y luego esperas 20 minutos mientras RunLocalTests ejecuta cada prueba en tu org, incluyendo ese antiguo AccountTest del 2018 que no tiene nada que ver con tu cambio."
                    },
                    {
                        "type": "text",
                        "value": "Salesforce nos escuchó. El nuevo nivel de prueba RunRelevantTests está en beta, y es exactamente lo que suena: ejecutar solo las pruebas que importan para tu despliegue."
                    },
                    {
                        "type": "heading",
                        "value": "El Problema con RunLocalTests"
                    },
                    {
                        "type": "text",
                        "value": "RunLocalTests es el predeterminado para despliegues a producción. Ejecuta cada prueba en tu org excepto los paquetes gestionados. En una org madura con cientos de clases de prueba, esto se vuelve lento. Muy lento. Y no escala, ya sea que despliegues una clase o cincuenta, estás ejecutando la misma suite masiva de pruebas."
                    },
                    {
                        "type": "text",
                        "value": "RunSpecifiedTests te permite elegir pruebas específicas, pero ahora necesitas herramientas DevOps personalizadas para averiguar qué pruebas ejecutar. Estás intercambiando tiempo de despliegue por tiempo de ingeniería."
                    },
                    {
                        "type": "heading",
                        "value": "Entra RunRelevantTests"
                    },
                    {
                        "type": "text",
                        "value": "RunRelevantTests analiza tu payload de despliegue y ejecuta solo las pruebas que son relevantes para lo que estás cambiando. El motor mira las dependencias, descubre qué está impactado, y ejecuta solo esas pruebas. ¿Despliegue pequeño? Ejecución de pruebas pequeña. Escala."
                    },
                    {
                        "type": "heading",
                        "value": "Cómo Usarlo"
                    },
                    {
                        "type": "text",
                        "value": "Si estás usando Salesforce CLI, es un solo flag:"
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "sf project deploy start --test-level RunRelevantTests"
                    },
                    {
                        "type": "text",
                        "value": "Si estás usando la API de Metadata directamente, configura el campo testLevel en tu DeployOptions:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "DeployOptions options = new DeployOptions();\noptions.testLevel = 'RunRelevantTests';\n// Pasa al método deploy()"
                    },
                    {
                        "type": "text",
                        "value": "Eso es todo. El motor maneja el resto."
                    },
                    {
                        "type": "heading",
                        "value": "Control Fino con Anotaciones"
                    },
                    {
                        "type": "text",
                        "value": "A veces necesitas más control. Salesforce agregó dos nuevas anotaciones @IsTest (disponibles en API versión 66.0+) para permitirte especificar el comportamiento de las pruebas."
                    },
                    {
                        "type": "heading",
                        "value": "@IsTest(critical=true)"
                    },
                    {
                        "type": "text",
                        "value": "Usa esto cuando una prueba debe ejecutarse SIEMPRE, sin importar qué hay en el despliegue. Piensa en pruebas de integración, flujos de extremo a extremo, o pruebas que validan lógica de negocio crítica a través de múltiples componentes."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@IsTest(critical=true)\nprivate class CriticalBusinessFlowTest {\n    @isTest\n    static void testEndToEndOrderProcessing() {\n        // Esto se ejecuta en CADA despliegue\n        // Usa con moderación\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "No abuses de esto. Si cada prueba es crítica, nada es crítico. Resérvalo para pruebas que genuinamente necesitan ejecutarse cada vez."
                    },
                    {
                        "type": "heading",
                        "value": "@IsTest(testFor='...')"
                    },
                    {
                        "type": "text",
                        "value": "Esta anotación te permite declarar dependencias explícitamente. Si tu prueba debe ejecutarse cuando clases o triggers específicos son modificados, lístalos:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@IsTest(testFor='ApexClass:AccountService, ApexTrigger:OpportunityTrigger')\nprivate class AccountOpportunityIntegrationTest {\n    @isTest\n    static void testAccountUpdateTriggersOpportunityLogic() {\n        // Se ejecuta cuando AccountService O OpportunityTrigger cambian\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Nota la sintaxis: 'ApexClass:NombreClase' o 'ApexTrigger:NombreTrigger'. Puedes listar múltiples componentes separados por comas."
                    },
                    {
                        "type": "heading",
                        "value": "Cuándo Usar RunRelevantTests"
                    },
                    {
                        "type": "text",
                        "value": "Esto es perfecto para pipelines CI/CD donde despliegas frecuentemente. Ciclos de retroalimentación más rápidos significan iteración más rápida. Pero recuerda: esto aún está en beta. Pruébalo primero en tus ambientes sandbox. Valida que el motor está seleccionando las pruebas correctas para tus casos de uso."
                    },
                    {
                        "type": "text",
                        "value": "Y no abandones RunLocalTests completamente. Para lanzamientos mayores o validación pre-producción, aún quieres la suite completa. RunRelevantTests es para velocidad durante el desarrollo, no para reemplazar pruebas comprensivas."
                    },
                    {
                        "type": "heading",
                        "value": "Los Detalles"
                    },
                    {
                        "type": "text",
                        "value": "1. Esto es beta. Espera cambios antes de GA.\n2. Aún necesitas cumplir el requisito de 75% de cobertura de código.\n3. El motor es inteligente, pero no es psíquico. Si tienes dependencias raras que no detecta, usa las anotaciones.\n4. Disponible solo en ediciones Enterprise, Performance, Unlimited y Developer."
                    },
                    {
                        "type": "heading",
                        "value": "La Conclusión"
                    },
                    {
                        "type": "text",
                        "value": "RunRelevantTests es una de esas funcionalidades que simplemente tiene sentido. Los despliegues deberían ser rápidos. Las pruebas deberían ser dirigidas. Si estás cansado de esperar que terminen pruebas no relacionadas, prueba esto. Solo recuerda que es beta, prueba exhaustivamente, proporciona retroalimentación a Salesforce, y no apuestes tus despliegues de producción en esto hasta que llegue a GA."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Deploy Apex Components Faster by Running Only Relevant Tests (Beta)",
                                "url": "https://help.salesforce.com/s/articleView?id=release-notes.rn_apex_run_relevant_tests.htm&release=260&type=5"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "picklist-values-record-type",
                "title": "Por Fin: Obtener Valores de Picklist por Tipo de Registro en Apex",
                "date": "2026-01-08",
                "summary": "Salesforce nos acaba de dar una forma nativa de obtener valores de picklist específicos por tipo de registro en Apex.",
                "content": [
                    {
                        "type": "text",
                        "value": "Si alguna vez intentaste obtener valores de picklist para un tipo de registro específico en Apex, conoces el dolor. O haces un callout a la UI API, usas algún workaround hacky con Schema.DescribeFieldResult, o simplemente te rindes y hardcodeas los valores. Ninguna de estas es buena."
                    },
                    {
                        "type": "text",
                        "value": "Salesforce nos escuchó en IdeaExchange. El nuevo método ConnectApi.RecordUi.getPicklistValuesByRecordType() está aquí, y hace exactamente lo que dice."
                    },
                    {
                        "type": "heading",
                        "value": "La Forma Antigua Era Dolorosa"
                    },
                    {
                        "type": "text",
                        "value": "Antes de esto, si querías valores de picklist filtrados por tipo de registro, tenías dos malas opciones:"
                    },
                    {
                        "type": "text",
                        "value": "1. Hacer un callout a la UI API desde Apex (asíncrono, complejo, límites del gobernador)\n2. Usar Schema describes y filtrar manualmente por tipo de registro (verboso, propenso a errores)"
                    },
                    {
                        "type": "text",
                        "value": "¿Y si tenías picklists dependientes? Buena suerte. Necesitarías múltiples llamadas o lógica compleja para recorrer el árbol de dependencias."
                    },
                    {
                        "type": "heading",
                        "value": "La Nueva Forma es Limpia"
                    },
                    {
                        "type": "text",
                        "value": "Un método. Una llamada. Todos tus valores de picklist para un tipo de registro específico."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Obtener todos los valores de picklist para un tipo de registro\nConnectApi.PicklistValuesCollection picklistValues = \n    ConnectApi.RecordUi.getPicklistValuesByRecordType(\n        'Account',           // Nombre API del objeto\n        '012xx000000abcdAAA'  // ID del Tipo de Registro\n    );"
                    },
                    {
                        "type": "text",
                        "value": "Eso es todo. El método retorna un PicklistValuesCollection que contiene todos los campos picklist y sus valores para ese tipo de registro."
                    },
                    {
                        "type": "heading",
                        "value": "Accediendo a los Valores"
                    },
                    {
                        "type": "text",
                        "value": "La colección retornada es un mapa de nombres API de campos a sus valores de picklist. Así es como accedes a ellos:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Obtener valores para un campo específico\nConnectApi.PicklistValues industryValues = \n    picklistValues.picklistFieldValues.get('Industry');\n\n// Recorrer los valores\nfor (ConnectApi.PicklistValue value : industryValues.values) {\n    System.debug('Etiqueta: ' + value.label);\n    System.debug('Valor API: ' + value.value);\n    System.debug('Es Default: ' + value.defaultValue);\n}"
                    },
                    {
                        "type": "heading",
                        "value": "La Funcionalidad Estrella: Picklists Dependientes"
                    },
                    {
                        "type": "text",
                        "value": "Aquí es donde se pone bueno. Si tienes un árbol de picklists dependientes, digamos Continent__c controla Country__c, que controla City__c, este método obtiene TODOS los valores en UNA llamada."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "ConnectApi.PicklistValuesCollection allPicklists = \n    ConnectApi.RecordUi.getPicklistValuesByRecordType(\n        'Location__c',\n        recordTypeId\n    );\n\n// Obtener valores de continente\nConnectApi.PicklistValues continents = \n    allPicklists.picklistFieldValues.get('Continent__c');\n\n// Obtener valores de país (incluye TODOS los países para TODOS los continentes)\nConnectApi.PicklistValues countries = \n    allPicklists.picklistFieldValues.get('Country__c');\n\n// Obtener valores de ciudad (incluye TODAS las ciudades para TODOS los países)\nConnectApi.PicklistValues cities = \n    allPicklists.picklistFieldValues.get('City__c');"
                    },
                    {
                        "type": "text",
                        "value": "Cada objeto PicklistValue incluye una propiedad validFor que te dice para qué valores controladores es válido. Así es como construyes la lógica de dependencia."
                    },
                    {
                        "type": "heading",
                        "value": "Ejemplo del Mundo Real"
                    },
                    {
                        "type": "text",
                        "value": "Digamos que estás construyendo una UI personalizada y necesitas poblar picklists basados en el tipo de registro seleccionado por el usuario:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@AuraEnabled\npublic static Map<String, List<PicklistOption>> getPicklistsForRecordType(\n    String objectName, \n    String recordTypeId\n) {\n    Map<String, List<PicklistOption>> result = new Map<String, List<PicklistOption>>();\n    \n    // Obtener todos los valores de picklist para este tipo de registro\n    ConnectApi.PicklistValuesCollection picklistData = \n        ConnectApi.RecordUi.getPicklistValuesByRecordType(\n            objectName,\n            recordTypeId\n        );\n    \n    // Convertir a un formato que tu LWC pueda usar\n    for (String fieldName : picklistData.picklistFieldValues.keySet()) {\n        List<PicklistOption> options = new List<PicklistOption>();\n        \n        ConnectApi.PicklistValues fieldValues = \n            picklistData.picklistFieldValues.get(fieldName);\n        \n        for (ConnectApi.PicklistValue pv : fieldValues.values) {\n            options.add(new PicklistOption(pv.label, pv.value));\n        }\n        \n        result.put(fieldName, options);\n    }\n    \n    return result;\n}\n\npublic class PicklistOption {\n    @AuraEnabled public String label;\n    @AuraEnabled public String value;\n    \n    public PicklistOption(String label, String value) {\n        this.label = label;\n        this.value = value;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Ahora tu LWC obtiene todos los valores de picklist que necesita en una sola llamada al servidor. No múltiples viajes de ida y vuelta. No filtrado del lado del cliente."
                    },
                    {
                        "type": "heading",
                        "value": "Cuándo Usar Esto"
                    },
                    {
                        "type": "text",
                        "value": "Usa este método cuando:\n- Estés construyendo UIs personalizadas que necesitan picklists específicos por tipo de registro\n- Estés trabajando con picklists dependientes y necesites el árbol completo de dependencias\n- Necesites validar valores de picklist en Apex basado en tipo de registro\n- Estés migrando datos y necesites asegurar que los valores son válidos para los tipos de registro objetivo"
                    },
                    {
                        "type": "heading",
                        "value": "¿Qué Pasa con LWC?"
                    },
                    {
                        "type": "text",
                        "value": "Si estás en LWC, ya tienes getPicklistValuesByRecordType del módulo lightning/uiObjectInfoApi. Este nuevo método Apex trae la misma capacidad del lado del servidor. Úsalo cuando necesites procesar lógica de picklist en Apex en lugar de JavaScript."
                    },
                    {
                        "type": "heading",
                        "value": "Los Detalles"
                    },
                    {
                        "type": "text",
                        "value": "1. Esto aún está en preview. Pruébalo exhaustivamente antes de depender de él en producción.\n2. El método retorna TODOS los campos picklist para el objeto. Si solo necesitas un campo, igual obtienes todos.\n3. Para picklists dependientes, obtienes todos los valores posibles. Aún necesitas implementar la lógica de filtrado basada en el campo controlador.\n4. Disponible solo en ediciones Enterprise, Performance, Unlimited y Developer."
                    },
                    {
                        "type": "heading",
                        "value": "La Conclusión"
                    },
                    {
                        "type": "text",
                        "value": "Esta es una de esas mejoras de calidad de vida que debería haber existido hace años. No más callouts. No más workarounds. Solo una forma limpia y nativa de obtener valores de picklist por tipo de registro."
                    },
                    {
                        "type": "text",
                        "value": "Si has estado evitando picklists dependientes en UIs personalizadas por la complejidad, prueba esto. Aún está en preview, pero es un cambio de juego para cualquiera que construya interfaces conscientes del tipo de registro."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Extract Picklist Values Based on Record Type",
                                "url": "https://help.salesforce.com/s/articleView?id=release-notes.rn_apex_extract_picklist_values.htm&release=260&type=5"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "mock-callouts-testing",
                "title": "Mock Callouts: Probando Integraciones Sin Internet",
                "date": "2026-01-08",
                "summary": "No puedes hacer callouts HTTP reales en tests de Apex. Aquí está cómo simularlos correctamente.",
                "content": [
                    {
                        "type": "text",
                        "value": "Dejemos esto claro: no puedes hacer callouts HTTP reales en métodos de prueba de Apex. Salesforce los bloquea. Punto. Si lo intentas, obtendrás un error 'Callout from triggers are currently not supported', aunque no estés en un trigger."
                    },
                    {
                        "type": "text",
                        "value": "Esto es por diseño. Las pruebas necesitan ser rápidas, deterministas y aisladas. Los callouts reales son lentos, impredecibles y dependen de sistemas externos que no controlas. Así que Salesforce te obliga a simularlos."
                    },
                    {
                        "type": "heading",
                        "value": "El Problema: Los Callouts Reales Están Prohibidos"
                    },
                    {
                        "type": "text",
                        "value": "Imagina que tienes una integración que llama a una API externa para validar direcciones. En producción, funciona bien. Pero cuando intentas probarla, la prueba falla porque Salesforce no te deja hacer la petición HTTP. Tu código es correcto, pero no puedes probarlo."
                    },
                    {
                        "type": "text",
                        "value": "Aquí es donde entra HttpCalloutMock. Es una interfaz que te permite simular respuestas HTTP sin hacer llamadas de red reales."
                    },
                    {
                        "type": "heading",
                        "value": "La Solución: HttpCalloutMock"
                    },
                    {
                        "type": "text",
                        "value": "La interfaz HttpCalloutMock tiene un método: respond(). Implementas este método para retornar un HttpResponse falso. Salesforce intercepta tu callout y usa tu mock en lugar de hacer la llamada de red."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\npublic class AddressValidationMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        // Crear una respuesta falsa\n        HttpResponse res = new HttpResponse();\n        res.setHeader('Content-Type', 'application/json');\n        res.setBody('{\"valid\": true, \"formatted\": \"123 Main St, San Francisco, CA 94105\"}');\n        res.setStatusCode(200);\n        return res;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Ahora en tu prueba, le dices a Salesforce que use este mock en lugar de hacer un callout real:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testAddressValidation() {\n    // Configurar el mock\n    Test.setMock(HttpCalloutMock.class, new AddressValidationMock());\n    \n    // Ejecutar tu código que hace un callout\n    Test.startTest();\n    Boolean isValid = AddressService.validateAddress('123 Main St');\n    Test.stopTest();\n    \n    // Afirmar el resultado\n    Assert.isTrue(isValid, 'La dirección debería ser válida');\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Mejor Práctica: Probar Múltiples Escenarios"
                    },
                    {
                        "type": "text",
                        "value": "No solo pruebes el camino feliz. Tu integración necesita manejar errores, timeouts y respuestas inesperadas. Crea diferentes mocks para diferentes escenarios."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Mock para respuesta de error\n@isTest\npublic class AddressValidationErrorMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        HttpResponse res = new HttpResponse();\n        res.setStatusCode(500);\n        res.setBody('{\"error\": \"Servicio no disponible\"}');\n        return res;\n    }\n}\n\n// Mock para dirección inválida\n@isTest\npublic class AddressValidationInvalidMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        HttpResponse res = new HttpResponse();\n        res.setStatusCode(200);\n        res.setBody('{\"valid\": false, \"reason\": \"Dirección no encontrada\"}');\n        return res;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Ahora puedes probar cómo tu código maneja fallas:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testAddressValidationError() {\n    Test.setMock(HttpCalloutMock.class, new AddressValidationErrorMock());\n    \n    Test.startTest();\n    try {\n        AddressService.validateAddress('123 Main St');\n        Assert.fail('Debería haber lanzado una excepción');\n    } catch (AddressService.ValidationException e) {\n        Assert.isTrue(true, 'Excepción capturada como se esperaba');\n    }\n    Test.stopTest();\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Avanzado: Mocks Dinámicos"
                    },
                    {
                        "type": "text",
                        "value": "A veces necesitas que tu mock se comporte diferente basado en la petición. Inspecciona el HttpRequest en tu método respond() y retorna diferentes respuestas según corresponda."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\npublic class SmartAddressMock implements HttpCalloutMock {\n    public HttpResponse respond(HttpRequest req) {\n        HttpResponse res = new HttpResponse();\n        res.setHeader('Content-Type', 'application/json');\n        \n        // Revisar el cuerpo de la petición\n        String body = req.getBody();\n        \n        if (body.contains('invalid-address')) {\n            res.setStatusCode(200);\n            res.setBody('{\"valid\": false}');\n        } else if (body.contains('error-trigger')) {\n            res.setStatusCode(500);\n            res.setBody('{\"error\": \"Error interno\"}');\n        } else {\n            res.setStatusCode(200);\n            res.setBody('{\"valid\": true}');\n        }\n        \n        return res;\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Esto te permite probar múltiples escenarios con una sola clase mock. Solo varía tus datos de prueba para disparar diferentes respuestas."
                    },
                    {
                        "type": "heading",
                        "value": "¿Deberías Centralizar tus Mocks?"
                    },
                    {
                        "type": "text",
                        "value": "Esto depende del tamaño de tu codebase y número de integraciones."
                    },
                    {
                        "type": "heading",
                        "value": "Codebase Pequeño (1-3 Integraciones)"
                    },
                    {
                        "type": "text",
                        "value": "Mantén los mocks en el mismo archivo que tus pruebas. Es simple, es claro, y no necesitas la sobrecarga de un sistema centralizado."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nprivate class AddressServiceTest {\n    // Clase mock aquí mismo\n    private class SuccessMock implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) {\n            // ...\n        }\n    }\n    \n    @isTest\n    static void testValidation() {\n        Test.setMock(HttpCalloutMock.class, new SuccessMock());\n        // lógica de prueba\n    }\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Codebase Mediano (4-10 Integraciones)"
                    },
                    {
                        "type": "text",
                        "value": "Crea una clase mock dedicada para cada integración. Esto mantiene tus clases de prueba limpias y hace que los mocks sean reutilizables a través de múltiples métodos de prueba."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "// Clase mock dedicada\n@isTest\npublic class AddressValidationMocks {\n    public class SuccessResponse implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) { /* ... */ }\n    }\n    \n    public class ErrorResponse implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) { /* ... */ }\n    }\n    \n    public class InvalidResponse implements HttpCalloutMock {\n        public HttpResponse respond(HttpRequest req) { /* ... */ }\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Ahora cualquier prueba puede usar estos mocks:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testSuccess() {\n    Test.setMock(HttpCalloutMock.class, new AddressValidationMocks.SuccessResponse());\n    // lógica de prueba\n}\n\n@isTest\nstatic void testError() {\n    Test.setMock(HttpCalloutMock.class, new AddressValidationMocks.ErrorResponse());\n    // lógica de prueba\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Codebase Grande (10+ Integraciones)"
                    },
                    {
                        "type": "text",
                        "value": "Construye una fábrica de mocks. Esto es especialmente útil si tienes múltiples integraciones con patrones de respuesta similares."
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\npublic class HttpMockFactory {\n    public static HttpCalloutMock createSuccessMock(String body) {\n        return new GenericMock(200, body);\n    }\n    \n    public static HttpCalloutMock createErrorMock(Integer statusCode) {\n        return new GenericMock(statusCode, '{\"error\": \"Algo salió mal\"}');\n    }\n    \n    private class GenericMock implements HttpCalloutMock {\n        private Integer statusCode;\n        private String body;\n        \n        public GenericMock(Integer statusCode, String body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n        \n        public HttpResponse respond(HttpRequest req) {\n            HttpResponse res = new HttpResponse();\n            res.setStatusCode(this.statusCode);\n            res.setBody(this.body);\n            res.setHeader('Content-Type', 'application/json');\n            return res;\n        }\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "El uso es limpio y declarativo:"
                    },
                    {
                        "type": "code",
                        "language": "java",
                        "value": "@isTest\nstatic void testIntegration() {\n    Test.setMock(\n        HttpCalloutMock.class, \n        HttpMockFactory.createSuccessMock('{\"status\": \"ok\"}')\n    );\n    // lógica de prueba\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Los Detalles"
                    },
                    {
                        "type": "text",
                        "value": "1. Test.setMock() aplica a TODOS los callouts en esa prueba. Si haces múltiples callouts a diferentes endpoints, necesitas un mock multi-endpoint o StaticResourceCalloutMock.\n2. Los mocks no validan tu petición. Si tu código envía JSON malformado, el mock igual retornará una respuesta. Necesitas inspeccionar manualmente req en tu mock si la validación importa.\n3. No hardcodees URLs de producción en tus mocks. Usa Custom Metadata o Named Credentials para que tus pruebas no se rompan cuando los endpoints cambien."
                    },
                    {
                        "type": "heading",
                        "value": "La Conclusión"
                    },
                    {
                        "type": "text",
                        "value": "Simular callouts no es opcional. Es la única forma de probar integraciones en Apex. Comienza simple con mocks inline, luego refactoriza a clases dedicadas o fábricas a medida que tu codebase crece."
                    },
                    {
                        "type": "text",
                        "value": "Y recuerda: prueba las fallas, no solo el camino feliz. Tu integración fallará en producción. Asegúrate de que tu código lo maneje con gracia."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "Testing HTTP Callouts",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_restful_http_testing.htm"
                            },
                            {
                                "title": "HttpCalloutMock Interface",
                                "url": "https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_interface_httpcalloutmock.htm"
                            }
                        ]
                    }
                ]
            },
            {
                "id": "typescript-lwc-preview",
                "title": "TypeScript en LWC: Por Fin, Seguridad de Tipos para tus Componentes",
                "date": "2026-01-08",
                "summary": "El soporte de TypeScript está aquí (en developer preview). Aquí está por qué importa y cómo prepararte para el lanzamiento.",
                "content": [
                    {
                        "type": "text",
                        "value": "Seamos honestos: la falta de seguridad de tipos de JavaScript ha sido un punto de dolor en el desarrollo de LWC. Te conectas a Apex (fuertemente tipado), trabajas con objetos de Salesforce (fuertemente tipados), pero ¿tu código LWC? JavaScript débilmente tipado. Hasta ahora."
                    },
                    {
                        "type": "text",
                        "value": "Salesforce acaba de lanzar soporte de TypeScript para LWC como developer preview. Esto es enorme. Déjame explicar por qué, y cómo deberías prepararte para cuando esto llegue a GA."
                    },
                    {
                        "type": "heading",
                        "value": "Por Qué TypeScript Importa para LWC"
                    },
                    {
                        "type": "text",
                        "value": "TypeScript es un superconjunto de JavaScript que agrega tipado estático. Escribes archivos .ts en lugar de .js, y el compilador de TypeScript verifica tus tipos en tiempo de compilación. Esto atrapa errores antes de que lleguen a producción."
                    },
                    {
                        "type": "heading",
                        "value": "La Conexión con Apex"
                    },
                    {
                        "type": "text",
                        "value": "Aquí está el beneficio clave: Apex está fuertemente tipado. Cuando llamas a un método Apex desde LWC, estás cruzando un límite de tipos. En JavaScript, no tienes idea de qué forma tienen los datos. Solo esperas que el método Apex retorne lo que esperas."
                    },
                    {
                        "type": "text",
                        "value": "Con TypeScript, puedes definir interfaces que coincidan con tus tipos de retorno de Apex. Ahora tu IDE sabe qué campos existen, cuáles son sus tipos, y puede autocompletarlos. No más errores de tipeo. No más errores de 'undefined is not a function'."
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "// Definir una interfaz que coincida con tu clase Apex\ninterface Contact {\n    Id: string;\n    FirstName: string;\n    LastName: string;\n    Email: string;\n    Phone?: string;  // Campo opcional\n}\n\n// Tu método Apex retorna List<Contact>\nimport getContacts from '@salesforce/apex/ContactController.getContacts';\n\nexport default class ContactList extends LightningElement {\n    contacts: Contact[] = [];\n    \n    async loadContacts() {\n        this.contacts = await getContacts();\n        \n        // TypeScript sabe que 'contacts' es un array de Contact\n        // Autocompletado funciona. Verificación de tipos funciona.\n        this.contacts.forEach(contact => {\n            console.log(contact.FirstName);  // ✓ Válido\n            console.log(contact.InvalidField);  // ✗ Error de compilación\n        });\n    }\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Ejemplo del Mundo Real: Wire Adapters"
                    },
                    {
                        "type": "text",
                        "value": "Los wire adapters son notorios por tipos de retorno poco claros. Con TypeScript, puedes ser explícito:"
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "import { LightningElement, wire } from 'lwc';\nimport { getRecord, GetRecordConfig } from 'lightning/uiRecordApi';\n\ninterface AccountRecord {\n    Id: string;\n    fields: {\n        Name: { value: string };\n        Industry: { value: string };\n        AnnualRevenue: { value: number | null };\n    };\n}\n\nexport default class AccountDetails extends LightningElement {\n    recordId: string = '001xx000003DGb2AAG';\n    account?: AccountRecord;\n    \n    @wire(getRecord, { \n        recordId: '$recordId', \n        fields: ['Account.Name', 'Account.Industry', 'Account.AnnualRevenue'] \n    })\n    wiredAccount({ data, error }: { data?: AccountRecord; error?: any }) {\n        if (data) {\n            this.account = data;\n            // TypeScript conoce la forma de 'account'\n            const name = this.account.fields.Name.value;\n            const revenue = this.account.fields.AnnualRevenue.value ?? 0;\n        }\n    }\n}"
                    },
                    {
                        "type": "heading",
                        "value": "Beneficios Más Allá de la Seguridad de Tipos"
                    },
                    {
                        "type": "text",
                        "value": "1. **Autocompletado**: Tu IDE sabe qué métodos y propiedades existen. No más adivinanzas.\n2. **Refactorización**: ¿Renombrar una propiedad? TypeScript actualiza todas las referencias. En JavaScript, estás haciendo buscar-y-reemplazar y esperando no haber perdido nada.\n3. **Documentación**: Los tipos son auto-documentados. No necesitas comentarios explicando qué espera una función.\n4. **Atrapar Errores Temprano**: Errores de tipeo, tipos incorrectos, propiedades faltantes, todo atrapado en tiempo de compilación, no en tiempo de ejecución."
                    },
                    {
                        "type": "heading",
                        "value": "Cómo Configurarlo (Developer Preview)"
                    },
                    {
                        "type": "text",
                        "value": "Esto aún está en developer preview, así que la configuración requiere algunos pasos. Primero, habilita el feature flag en la configuración de VS Code:"
                    },
                    {
                        "type": "code",
                        "language": "json",
                        "value": "// .vscode/settings.json\n{\n    \"salesforcedx-vscode-lwc.preview.typeScriptSupport\": true\n}"
                    },
                    {
                        "type": "text",
                        "value": "Esto crea un tsconfig.json en tu carpeta lwc. Luego instala TypeScript (mínimo v5.4.5):"
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "npm install --save-dev typescript@5.4.5"
                    },
                    {
                        "type": "text",
                        "value": "Ahora puedes crear archivos .ts en lugar de .js. Pero aquí está el truco: Salesforce no compila TypeScript. Tienes que compilarlo tú mismo antes de desplegar."
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "# Compilar todos los archivos TypeScript a JavaScript\ntsc"
                    },
                    {
                        "type": "text",
                        "value": "Esto genera archivos .js junto a tus archivos .ts. Despliegas el JavaScript. El TypeScript permanece en tu control de versiones."
                    },
                    {
                        "type": "heading",
                        "value": "El Workaround de los Decoradores"
                    },
                    {
                        "type": "text",
                        "value": "Hay una peculiaridad. La opción experimentalDecorators de TypeScript debe estar en false, pero esto hace que TypeScript se queje de los decoradores de LWC como @api, @track y @wire."
                    },
                    {
                        "type": "text",
                        "value": "¿El workaround? Agregar // @ts-expect-error arriba de cada decorador:"
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "export default class MyComponent extends LightningElement {\n    // @ts-expect-error\n    @api recordId: string;\n    \n    // @ts-expect-error\n    @track privateData: any[] = [];\n    \n    // @ts-expect-error\n    @wire(getRecord, { recordId: '$recordId' })\n    wiredRecord({ data, error }: any) {\n        // ...\n    }\n}"
                    },
                    {
                        "type": "text",
                        "value": "Es feo, pero temporal. Salesforce está trabajando en arreglar esto antes de GA."
                    },
                    {
                        "type": "heading",
                        "value": "Lo Que Falta (Por Ahora)"
                    },
                    {
                        "type": "text",
                        "value": "Esto es un developer preview. Algunas cosas aún no funcionan:\n\n1. **Integración con Salesforce CLI**: No puedes desplegar TypeScript directamente con comandos sfdx o sf. Tienes que compilar primero.\n2. **Tipos de objetos personalizados**: No hay tipos auto-generados para tus objetos personalizados de Salesforce. Tienes que escribir interfaces manualmente.\n3. **Depuración de source maps**: No puedes depurar TypeScript en el navegador. Estás depurando el JavaScript compilado.\n4. **Definiciones de tipos limitadas**: No todos los módulos LWC tienen tipos aún. @salesforce/lightning-types aún está creciendo."
                    },
                    {
                        "type": "heading",
                        "value": "Cómo Prepararte para GA"
                    },
                    {
                        "type": "text",
                        "value": "No esperes a GA para empezar a aprender TypeScript. Aquí está lo que deberías hacer ahora:"
                    },
                    {
                        "type": "heading",
                        "value": "1. Aprende los Básicos de TypeScript"
                    },
                    {
                        "type": "text",
                        "value": "Si nunca has usado TypeScript, comienza con los fundamentos. Interfaces, tipos, genéricos, tipos de unión. No necesitas ser un experto, pero necesitas estar cómodo."
                    },
                    {
                        "type": "heading",
                        "value": "2. Configura un Proyecto de Prueba"
                    },
                    {
                        "type": "text",
                        "value": "Crea un scratch org, habilita el feature flag, y convierte un componente simple a TypeScript. Familiarízate con el flujo: escribir .ts, compilar a .js, desplegar .js."
                    },
                    {
                        "type": "heading",
                        "value": "3. Define Interfaces para tus Clases Apex"
                    },
                    {
                        "type": "text",
                        "value": "Comienza a documentar tus tipos de retorno de Apex como interfaces TypeScript. Cuando GA llegue, ya las tendrás listas."
                    },
                    {
                        "type": "code",
                        "language": "typescript",
                        "value": "// types/apex.ts\nexport interface OpportunityWrapper {\n    opportunity: {\n        Id: string;\n        Name: string;\n        StageName: string;\n        Amount: number;\n        CloseDate: string;\n    };\n    relatedContacts: Contact[];\n    lineItems: OpportunityLineItem[];\n}\n\nexport interface Contact {\n    Id: string;\n    FirstName: string;\n    LastName: string;\n    Email: string;\n}\n\nexport interface OpportunityLineItem {\n    Id: string;\n    ProductName: string;\n    Quantity: number;\n    UnitPrice: number;\n}"
                    },
                    {
                        "type": "heading",
                        "value": "4. Usa Control de Versiones"
                    },
                    {
                        "type": "text",
                        "value": "Salesforce no almacena tus archivos TypeScript. Solo el JavaScript compilado se despliega. DEBES usar Git u otro sistema de control de versiones. Agrega tus archivos .js a .gitignore y solo commitea archivos .ts."
                    },
                    {
                        "type": "code",
                        "language": "bash",
                        "value": "# .gitignore\n# Ignorar JavaScript compilado (solo commiteamos TypeScript)\nforce-app/main/default/lwc/**/*.js\nforce-app/main/default/lwc/**/*.js.map"
                    },
                    {
                        "type": "heading",
                        "value": "5. Planea tu Estrategia de Migración"
                    },
                    {
                        "type": "text",
                        "value": "No tienes que convertir todo de una vez. Comienza con componentes nuevos. Migra gradualmente los existentes. TypeScript y JavaScript pueden coexistir en el mismo proyecto."
                    },
                    {
                        "type": "heading",
                        "value": "La Conclusión"
                    },
                    {
                        "type": "text",
                        "value": "TypeScript en LWC es un cambio de juego. Trae la seguridad de tipos que te ha estado faltando, especialmente cuando trabajas con Apex. El developer preview tiene bordes ásperos, pero el valor central está ahí."
                    },
                    {
                        "type": "text",
                        "value": "Comienza a aprender ahora. Configura un proyecto de prueba. Ponte cómodo con el flujo de trabajo. Cuando esto llegue a GA, estarás listo para migrar tus componentes y finalmente tener la seguridad de tipos que mereces."
                    },
                    {
                        "type": "text",
                        "value": "¿Y si ya estás usando TypeScript en otros proyectos? Sabes exactamente por qué esto importa. Bienvenido al futuro del desarrollo de LWC."
                    },
                    {
                        "type": "sources",
                        "links": [
                            {
                                "title": "TypeScript Type Definitions for LWC (Developer Preview)",
                                "url": "https://developer.salesforce.com/docs/platform/lwc/guide/ts.html"
                            }
                        ]
                    }
                ]
            }
        ]
    }
}